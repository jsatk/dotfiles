/* global dependencies */
var accounting  = require('accounting');
var _           = require('underscore');
var $           = require('jquery');
var moment      = require('moment');
var Validatable = require('advisor/extensions/Validatable');
var Marionette  = require('backbone.marionette');
var AppChannel  = require('advisor/app-channel');

/* local dependencies */
var Helpers         = require('../../../config/helpers');
var CampaignChannel = require('../campaign-channel');
var CommonLanguage  = require('advisor/common/language');
var platforms       = require('advisor/common/platforms');

/* templates */
var CampaignBudgetObjectEditCard = require('../templates/CampaignBudgetObjectiveEditCard.hbs');

/* module definition */
module.exports = Marionette.ItemView.extend(new Validatable({
    template: CampaignBudgetObjectEditCard,
    budgetAdjustments: CommonLanguage.en.budget_adjustment,
    _platforms: platforms(),
    modelEvents: {
        'change:insertion_order': 'setDateRange',
        'change:objective': 'onChangeObjective'
    },
    onRender: function() {
        this.setDateRange();
        /** Allows us to use Marionette's UI syntax with stickit. */
        this.bindings = Marionette.normalizeUIKeys(this.bindings, this._uiBindings);
        this.stickit();
        this.model.startTracking();
    },
    /** @return {Object} */
    templateHelpers:function() {
        return {
            kpiLabel: this.model.kpiLabel(),
            dateRangeEnabled: Boolean(this.model.get('insertion_order'))
        };
    },
    validate: {
        /**
         * @param {$.Element} el
         * @param {String} name
         * @return {null}
         */
        budget: function(el, name) {
            var value = el.val();

            if (value < this.model.get('spend_lifetime')) return 'Budget cannot be less than Total Spend';
            // TODO: This seems very suspect.  Update to use alternative method.
            if (Number(value) === this.model._originalAttrs.budget) {
                this.ui.budgetAdjustment.hide();
            }

            return null;
        },
        /**
         * @param {$.Element} el
         * @param {String} name
         * @return {null}
         */
        kpi_goal: function(el, name) {
            var value = el.val();

            if (value < 0) return 'KPI Goal must be a positive value';

            return null;
        },
        /**
         * @param {$.Element} el
         * @param {String} name
         * @return {null}
         */
        start_date: function(el, name) {
            var value = el.val();

            if (this.isOriginalDate(value, 'start_date')) return null;
            if (this.isEarlierThanCurrentDate(value)) return 'Start Date cannot be earlier than current date';

            return null;
        },
        /**
         * @param {$.Element} el
         * @param {String} name
         * @return {null}
         */
        end_date: function(el, name) {
            var value = el.val();

            if (this.isOriginalDate(value, 'end_date')) return null;
            if (this.isEarlierThanCurrentDate(value)) return 'End Date cannot be earlier than current date';

            return null;
        }
    },
    ui: {
        budget:                    '#budget',
        kpiGoal:                   '#kpi_goal',
        objective:                 '#objective_select',
        kpi:                       '#kpi',
        budgetAdjustment:          '#budget_adjustment',
        budgetAdjustmentSelect:    '#budget_adjustment_select',
        budgetAdjustmentOther:     '#budget_adjustment_other',
        budgetAdjustmentOtherText: '#budget_adjustment_other_text',
        startDate:                 '#start_date',
        endDate:                   '#end_date'
    },
    events: {
        'change @ui.budget': 'handleBudgetUpdate',
        'change @ui.budgetAdjustment': 'handleBudgetAdjustmentUpdate'
    },
    bindings: {
        '@ui.startDate': {
            observe: 'start_date',
            onGet: 'getISODateInUSCivilian',
            onSet: 'getUSCivilianDateInISO'
        },
        '@ui.endDate': {
            observe: 'end_date',
            onGet: 'getISODateInUSCivilian',
            onSet: 'getUSCivilianDateInISO'
        },
        '@ui.budget': {
            observe: 'budget',
            onSet: 'accountingUnformat'
        },
        '@ui.kpiGoal': {
            observe: 'kpi_goal',
            onSet: 'accountingUnformat'
        },
        '@ui.budgetAdjustmentSelect': {
            observe: 'budget_adjustment_select',
            selectOptions: {
                collection: 'this.budgetAdjustments',
                defaultOption: {
                    label: 'Select Reason',
                    value: null
                }
            }
        },
        '@ui.budgetAdjustmentOtherText': {
            observe: 'budget_adjustment_other_text'
        },
        '@ui.objective': {
            observe: ['objective', 'platform', 'subplatform'],
            selectOptions: {
                /** @return {Array} */
                collection: function() {
                    return this.getObjectives();
                },
                defaultOption: {
                    label: 'Select Objective',
                    value: null
                }
            },
            onGet: _.first,
            /**
             * @param {String}
             * @return {Array}
             */
            onSet: function(val) {
                this.model.set('kpi', null);

                return [
                    val,
                    this.model.get('platform'),
                    this.model.get('subplatform')
                ];
            }
        },
        '@ui.kpi': {
            observe: ['kpi', 'objective', 'platform', 'subplatform'],
            selectOptions: {
                /** @return {Array} */
                collection: function() {
                    var objectives = this.getObjectives();
                    return this.getKpis(objectives);
                },
                defaultOption: {
                    label: 'Select KPI',
                    value: null
                }
            },
            onGet: _.first,
            /**
             * @param {String}
             * @return {Array}
             */
            onSet: function(val) {
                return [
                    val,
                    this.model.get('objective'),
                    this.model.get('platform'),
                    this.model.get('subplatform')
                ];
            }
        }
    },
    behaviors: {
        DateRangeValidate: {}
    },
    /**
     * @param {String} val - MM/DD/YYYY formatted date
     * @param {String} date
     * @return {Boolean}
     * Handle the rare (?) cases where a user may select a new Start/End Date value, then change it
     * back to the original value.  Since we only want to send the edited values, we'll remove any
     * value changed and then set back to it's original value.  This is automatically handled by
     * backbone-trackit for the non-date fields, but because the dates are formatted through moment,
     * trackit cannot tell that a date has been set back to its original value.
     */
    isOriginalDate: function(value, date) {
        return value === moment(this.model._originalAttrs[date], 'YYYY-MM-DDTHH:mm:ss').format('MM/DD/YYYY');
    },
    /** @return {Boolean} */
    isEarlierThanCurrentDate: function(value) {
        return value < moment().startOf('day').format('MM/DD/YYYY');
    },
    handleBudgetUpdate: function() {
        this.ui.budgetAdjustment.show();
        this.ui.budgetAdjustment.trigger('change');
    },
    handleBudgetAdjustmentUpdate: function() {
        var budgetReason = this.ui.budgetAdjustmentSelect.find('option:selected').text();
        this.ui.budgetAdjustmentOther.toggle(budgetReason === 'Other');
    },
    /**
     * @param {String} value - DateTime in YYYY-MM-DD format.
     * @return {String}
     */
    getISODateInUSCivilian: function(value) {
        return moment(value, 'YYYY-MM-DD').format('MM/DD/YYYY');
    },
    /**
     * @param {String} value - DateTime in MM/DD/YYYY format.
     * @return {String}
     */
    getUSCivilianDateInISO: function(value) {
        return moment(value, 'MM/DD/YYYY').format('YYYY-MM-DD');
    },
    /**
     * @param {String} value
     * @return {String}
     */
    accountingUnformat: function(value) {
        return accounting.unformat(value);
    },
    /** @return {Array} */
    getObjectives: function() {
        var platformId = this.model.getEffectivePlatform();
        var platforms = this._platforms.filter(function(platform) {
            return platform.value === platformId;
        });
        var objectives = [];
        if (platforms.length > 0) {
            objectives = platforms[0].objectives;
        }
        return objectives;
    },
    /**
     * @param {Object} objectives
     * @return {Array}
     */
    getKpis: function(objectives) {
        var objective_id = this.model.get('objective');
        var _objectives = objectives.filter(function(objective) {
            return objective.value === objective_id;
        });
        var kpis = [];
        if (_objectives.length > 0) {
            kpis = _objectives[0].kpis;
        }
        return kpis;
    },
    /** @param {Object} dateRange */
    onChangeDateRange: function(dateRange) {
        var isDisabled = !Boolean(dateRange);

        // Disables/Enables various inputs based on us having a dateRange
        // which implys we have an Insertion Order.
        _(['budget', 'startDate', 'endDate']).each(function(el) {
            this.ui[el].prop('disabled', isDisabled);
        }, this);

        // Return early if we still don't have an dateRange
        if (isDisabled) return;

        // Set new range
        this.ui.startDate.datepicker('setStartDate', dateRange.beginning);
        this.ui.endDate.datepicker('setEndDate', dateRange.ending);

        // If the current end date is null or after the range's end date then
        // set the endDate datepicker's date to the range's end date.
        if (_.isNull(this.ui.endDate.datepicker('getDate')) ||
            this.ui.endDate.datepicker('getDate') > dateRange.ending) {
            this.ui.endDate.datepicker('setDate', dateRange.ending);
        }

        // If the current start date is null or before the range's start date then
        // set the startDate datepicker's date to the range's end date.
        if (_.isNull(this.ui.endDate.datepicker('getDate')) ||
            this.ui.startDate.datepicker('getDate') < dateRange.beginning) {
            this.ui.startDate.datepicker('setDate', dateRange.beginning);
        }

        // Once we have a date range (which implicitly tells us that we have an
        // insertion order) you can now choose an objective if you don't have one.
        this.ui.objective.prop('disabled', false);
    },
    /**
     * @param {Backbone.Model} model
     * @param {Object} objective
     * Disables the KPI select if we do not have an objective.
     * Enables the KPI select if we do have an objective.
     */
    onChangeObjective: function(model, objective) {
        this.ui.kpi.prop('disabled', !Boolean(objective));
    },
    /**
     * Fetches the Insertion Order.  Then gets the smallest date range between
     * the Initiative and the Insertion Order.  Then calls a method to update
     * the date range pickers.
     */
    setDateRange: function() {
        var insertionOrderUri = this.model.get('insertion_order');

        // If Campaign doesn't have an insertion order return.
        if (!insertionOrderUri) return;

        var insertionOrderID = Number(
            insertionOrderUri.match(/(\d+)\D*$/).pop()
        );

        /** @param {Backbone.Model} insertionOrder */
        function getDateRange(insertionOrder) {
            // We want to set our date range to the most restrictive possible.
            var today               = new Date();
            var ioStartDate         = moment(insertionOrder.get('start_date'), 'YYYY-MM-DD').toDate();
            var ioEndDate           = moment(insertionOrder.get('end_date'), 'YYYY-MM-DD').toDate();
            var initiativeStartDate = moment(this.getOption('initiative').get('start_date'), 'YYYY-MM-DD').toDate();
            var initiativeEndDate   = moment(this.getOption('initiative').get('end_date'), 'YYYY-MM-DD').toDate();
            var startDate           = _.max([ioStartDate, initiativeStartDate, today]); // Get the *earliest* start date.
            var endDate             = _.min([ioEndDate, initiativeEndDate]);            // Get the *soonest* end date.

            this.onChangeDateRange({
                beginning: startDate,
                ending: endDate
            });
        }

        $.when(
            AppChannel.request('advisor:insertionorder:entity', insertionOrderID)
        ).done(
            _(getDateRange).bind(this)
        );
    }
}));
