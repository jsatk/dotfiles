Hi, Suhas & Brennan—

I know I've spoken to you both, particularly Brennan, about my desire for a senior/leadership role. Not from a managerial stand-point, but from a technical and project architecture standpoint.

As you know when I started I came up with a list of goals. Things I saw missing that I thought I could add and would be huge and largely agreed-upon wins. Here's that list:

* Remove all trailing whitespace ✓
* Esnure no mixed line-endings ✓
* Ensure new blank line at the end of all files ✓
* Use only single-quotes in the JS ✓ (In code reveiw)
* Adopt a style guide for JS. I suggest using [Airbnb's style guide](https://github.com/airbnb/javascript) ✓
* Adopt a style guide for Less
* Consistent agreed upon organization of JS ✓
* Full test coverage ✓ (Kind of. Got a test suite up and tested core components. More needed).
* Implement test threshold tool. (A tool that will analyze percentage of JS code that is tested and won't let you commit if you drop below a certian threshold. I don't currently have on in mind so I'd have to do some research.)
* Implement a pre-commit hook that disallows you to commit unless all tests and linters are passed. ✓

All of these except for the Less styleguide as well as the test threshold have been done accomplished. I realize these aren't neicessarily OKRs or in the format of OKRs but I do believe it illustrates that I am highly self-motivated and when I see a problem I bring a solution to the table to fix it.

The engineers didn't do OKRs last quarter for whatever reason, but I've heard we will be going forward. I wanted to get a jump on that and run my OKRs by you early.

My Q3 OKRs

1. Remove Marionette's module system and instead use Browserify (just like Message Optics).

    Marionette's module loading system is awful (no seriously the author of Marionette himself apologized for how bad it is here: http://derickbailey.com/2014/06/10/browserify-my-new-choice-for-modules-in-a-browser-backbone-app/) and has forced us to use several hacks as a work-around. I think we'd really benefit greatly from using browserify. It provides clarity as to *where* a file lives making finding the source of the thing you're working on or using infinitely easier. It also gets rid of the whole issue where if need file `b.js` in file `a.js` you... well... can't. I could write about this for hours. Bottomline is we need to embrace browserify and get not use Marionette's module system.

2. One "class" per file

    This is somewhat tied to the first goal. But ultimately it is a seperate thing. I believe having one class per file will provide us with great clarity and be especially appreciated by any new developers who dive into this code base.

3. Test all the apps

    As you probably know I'm a big fan of testing. I believe strongly in it especially since we don't have a QA department. Testing a legacy app (legacy in this case being any code written before the testing infastructure was in place which in this case is all of it) is always a challenge but a challenge I have tackled a few times in my career. I think if we can get our code base tested and we are *confident* in our tests then we can add it to the build process. This means *so much* if we can get this in place. It will mean our new code isn't breaking any old functionality. It will also mean tests written around our new code should a) exist b) help teach other devs reviewing the code *how* the code works. This is *huge*. I truly believe this can be done if the time is alotted for it and I believe it's wildly valuable.
