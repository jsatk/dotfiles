module.exports = function(grunt) {
    // Libraries required using CommonJS syntax.
    var request   = require('superagent'); // Allows us to make ajax requests in grunt. No jquery required!
    var _         = require('underscore'); // You know what this is.
    var async     = require('async');      // This library lets us run methods... wait for it... wait... asynchronously.

    var username   = 'test@test.com'; // Test credentials. User's cookie is used to fetch schema JSON.
    var password   = 'test';          // Test credentials. User's cookie is used to fetch schema JSON.
    var sessionUrl = 'https://alpha.socialcodedev.com/api/bouncer/v2/auth/session/';

    // Variable assignments
    var cookie    = '';
    var fixtures  = {};
    var dataTypes = grunt.file.readJSON('tests/dummyTestData.json');

    // Get our API JSON requests. NOTE: Grunt's #readJSON method is lovely. We do not need to parse the JSON.
    var apis = grunt.file.readJSON('tests/apiRequests.json');

    return function() {
        var done      = this.async(); // Wait till we are done with everything Grunt!
        // This is the big async command that runs everything in order nicely and cleanly.
        async.waterfall([
            fetchTestUserJSON,
            fetchSchemasJSON,
            createFixtureJSON,
            writeFixtureJSONToDisk
        ], done);
    };

    /****************
     * Main Methods *
     ****************/

    /** @param {Function} next Tells async waterfall to call the next method. */
    function fetchTestUserJSON(next) {
        request
            .post(sessionUrl)
            .send({ username: username, password: password })
            .end(onEnd);

        function onEnd(error, response) {
            cookie = response.header['set-cookie'][0];
            next(null);
        }
    }

    /** @param {Function} next Tells async waterfall to call the next method. */
    function fetchSchemasJSON(next) {
        async.map(apis, getSchemaJSON, next);
    }

    /**
     * @param {Object} schemas Our schema data telling us what properties we have and what types they should be.
     * @param {Function} next Tells async waterfall to call the next method.
     */
    function createFixtureJSON(schemas, next) {
        /**
         * @param {Object} schema
         * @param {Number} apiIndex
         */
        _(schemas).each(function(schema, apiIndex) {
            createFixtureDataPerSchema(schema, apiIndex);
        });

        next(null, schemas);
    }

    /**
     * @param {Array.<Object>} schemas
     * @param {Function} next Tells async waterfall to call the next method.
     */
    function writeFixtureJSONToDisk(schemas, next) {
        /**
         * @param {Object} schema
         * @param {Number} apiIndex
         */
        _(schemas).each(function(schema, apiIndex) {
            var path     = apis[apiIndex].path;
            var fauxData = JSON.stringify(fixtures[path], null, '\t'); // Use the tab character to indent our JSON.
            var filename = path.replace(/\//g, '.');

            // Writes the file to disk relative to where the Gruntfile.js is located.
            grunt.file.write('tests/fixtures/' + filename + '.json', fauxData);
        });

        next(null);
    }

    /*********************
     * “Private” Methods *
     *********************/

    /**
     * @param {Array.<Object>} api
     * @param {Function} next Tells async waterfall to call the next method.
     */
    function getSchemaJSON(api, next) {
        fixtures[api.path] = {};

        var url  = 'https://alpha.socialcodedev.com/api/' + api.path + '/schema/';
        var data = _({ format: 'json' }).extend(api.data || {});

        requestSchemaJSON(url, data, next);
    }

    /**
     * @param {String} url
     * @param {Object} data
     * @param {Function} next Tells async waterfall to call the next method.
     */
    function requestSchemaJSON(url, data, next) {
        /** @returns {String} */
        function getPath() {
            var path = url.substring(url.indexOf('api') + 4);

            return path.substring(0, path.indexOf('/schema/'));
        }

        request
            .get(url)
            .send(data)
            .set('Accept', 'application/json')
            .set('Cookie', cookie)
            .end(onEnd);

        /**
         * @param {Object} error
         * @param {Object} response
         */
        function onEnd(error, response) {
            // If there was an error throw an error and stop everything.
            if (error) { throw new Error(error); }

            var path = getPath();

            /**
             * @param {Object} value
             * @param {String} key
             */
            _(response.body.fields).each(function(value, key) {
                fixtures[path][key] = { type: value.type };
            });

            next(null, fixtures[path]);
        }
    }

    /**
     * @param {Object} schema
     * @param {String} apiPath
     */
    function createFixtureDataPerSchema(schema, apiIndex) {
        /**
         * @param {Object} property
         * @param {String} key
         */
        _(schema).each(function(property, key) {
            fixtures[apis[apiIndex].path][key] = getFixtureDataForProperty(property);
        });
    }

    /**
     * Randomly assigns a value of the appropriate type to each property in the faux data set.
     * Then calls the method that writes a file to disk named after the API Path.
     * @param {Object} property Has one property on it - `type` - which specifies what type this property should be.
     * @returns {*}
     */
    function getFixtureDataForProperty(property) {
        switch (property.type) {
        case 'decimal':
        case 'float':    return _.random(1, 1000) + (_.random(0, 100) * 0.001);
        case 'integer':  return _.random(1, 1000);
        case 'datetime': return new Date().toISOString();
        default:         return dataTypes[property.type][getRandomInteger()];
        }

        /** @returns {Number} */
        function getRandomInteger() {
            var maxNumber = dataTypes[property.type].length - 1;

            return _.random(0, maxNumber);
        }
    }
};
