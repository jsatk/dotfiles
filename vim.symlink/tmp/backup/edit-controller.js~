/* global dependencies */
var $ = require('jquery');
var _ = require('underscore');
var moment = require('moment');
var AppChannel = require('advisor/app-channel');

/* local dependencies */
var CampaignChannel = require('../campaign-channel');
var EditLayoutView = require('./edit-layout-view');
var EditDetailsView = require('./edit-details-view');
var EditBudgetObjectiveView = require('./edit-budget-objective-view');
var TargetingController = require('../targeting/targeting-controller');
var InsertionOrderController = require('../insertion/insertion-controller');
var TrackingController = require('../tracking/tracking-controller');
var EditSummaryController = require('../edit/edit-summary-controller');

/* module definition */
var Edit = {};

Edit.init = function(options) {
    if (!options || !options.region || !options.campaignID) {
        throw new Error('Invalid options passed to edit controller init.');
    }

    AppChannel.request('advisor:initiative:entity', options.initiativeID).done(function(initiative) {
        AppChannel.request('advisor:campaign:entity', options.campaignID).done(function(campaign) {
            if (!campaign.userCanManage()) {
                return AppChannel.trigger('permissionDenied');
            }
            var SCAcctId = campaign.get('account').match('account/(.*)[/]').pop();
            campaign.set('budget_remaining', campaign.get('budget') - campaign.get('spend_lifetime'));
            AppChannel.request('advisor:account:entity', SCAcctId).done(function(account) {
                /** Get readable Account name */
                var acctName = account.get('display_name').split('@').shift();
                campaign.set('account_name', acctName);

                loadEditView({
                    initiative: initiative,
                    campaign: campaign,
                    region: options.region
                });

            });
        });
    });
};

var loadEditView = function(options) {
    var layoutView = new EditLayoutView(options);

    layoutView.loadCards = loadCards;
    layoutView.loadToolbar = loadToolbar;
    layoutView.on({
        'show': function() {
            this
                .loadToolbar()
                .loadCards();
        }
    });

    options.region.show(layoutView);
    AppChannel.trigger('usage:pageevent', 'Campaign Detail', 'Edit');
};

var loadCards = function() {
    var platform = this.getOption('campaign').getPlatform();
    var cards = [
        {   load: loadDetailsCardView,
            region: 'details'
        },
        // {
        //     load: loadBudgetObjectCardView,
        //     region: 'budgetObjective'
        // },
        {   load: InsertionOrderController.loadCardView,
            region: 'insertionOrder'
        },
        {
            load: EditSummaryController.loadCardView,
            region: 'sub-1'
        }
    ];

    switch (platform) {
        case 'facebook':
            cards = cards.concat([
                {
                    load: TrackingController.loadCardView,
                    region: 'tracking'
                },
                {
                    load: TargetingController.loadCardView,
                    region: 'targeting'
                }
            ]);

            break;
        case 'twitter':
            cards = cards.concat([
                {
                    load: TargetingController.loadCardView,
                    region: 'targeting'
                }
            ]);

            break;
        case 'pinterest':
            // nothing needed, pinterest uses the defaults.
            break;
        default:
            throw new Error('Found invalid platform when trying to load campaign edit controller.');
    }

    _.each(cards, function(card) {
        card.load({
            region:     this.getRegion(card.region),
            initiative: this.options.initiative,
            campaign:   this.options.campaign
        });
    }, this);

    return this;
};

var loadToolbar = function() {
    /** Get & show detail-edit toolbar view */
    $.when(
       this.options.campaign,
       AppChannel.request('brand:entity', this.options.initiative.get('brand_id'))
    ).done(function(campaign, brand) {
        var subNavs = [
            {
                'bLogo':    brand.get('logo'),
                'bName':    brand.get('name'),
                'iName':    campaign.get('name'),
                'platform': campaign.getEffectivePlatform()
            }
        ];

        var toolbarViewOptions = {
            showNavToolbar: true,
            subNavs:        subNavs,
            viewName:       'detail-edit'
        };

        AppChannel.trigger('header:toolbar:show', toolbarViewOptions);
    });

    return this;
};

var loadDetailsCardView = function(options) {
    options = options || {};
    if (!options.region) throw new Error('Edit Controller requires a region option for Details.');
    var initiative = options.initiative;
    var campaign = options.campaign;
    var cardView = new EditDetailsView({
        model: campaign,
        initiative: initiative
    });
    options.region.show(cardView);
};

var loadBudgetObjectCardView = function(options) {
    options = options || {};
    if (!options.region) throw new Error('Edit Controller requires a region option for Budget and Objective.');
    var initiative = options.initiative;
    var campaign = options.campaign;
    var cardView = new EditBudgetObjectiveView({
        model: campaign,
        initiative: initiative
    });
    options.region.show(cardView);
};

/**
* Handle the rare (?) cases where a user may select a new Start/End Date value, then change it
* back to the original value.  Since we only want to send the edited values, we'll remove any
* value changed and then set back to it's original value.  This is automatically handled by
* backbone-trackit for the non-date fields, but because the dates are formatted through moment,
* trackit cannot tell that a date has been set back to its original value.
*/
var checkDates = function(edits, originalAttrs) {
    function equalsOriginalDate(date) {
        return edits[date] && edits[date] === moment(originalAttrs[date], 'YYYY-MM-DDTHH:mm:ss').format('YYYY-MM-DD');
    }

    if (equalsOriginalDate('start_date')) edits = _(edits).omit('start_date');
    if (equalsOriginalDate('end_date')) edits = _(edits).omit('end_date');

    return edits;
};

var editCampaign = _(function(model) {
    var edits = checkDates(model.unsavedAttributes(), model._originalAttrs);

    /** Only proceed if there are edits */
    if (!_(edits).isEmpty()) {

        if (edits.hasOwnProperty('budget_adjustment_select')) {
            var pre_adjustment_budget = model._originalAttrs.budget;
            var amount = edits.budget - pre_adjustment_budget;
            $.ajax({
                url: '/api/advisor/v1/budgetadjustment/',
                type: 'post',
                data: JSON.stringify({
                    campaign: model._originalAttrs.resource_uri,
                    pre_adjustment_budget: pre_adjustment_budget, //Budget before the adjustment
                    amount: amount, // Amount by which budget is being increased or decreased
                    adjustment_type: edits.budget_adjustment_select,
                    notes: edits.budget_adjustment_other_text || ''
                }),
                contentType: 'application/json',
                error: _(function(model, response) {
                    this.triggerMethod('Error', response.responseText);
                }).bind(this)
            });
        }

        // removing model.unsavedAttributes check, since it seems to capture only changes to the node, but not it's children
        var immutableFields = ['account', 'ad_clusters'];
        _.each(immutableFields, function(field) {
            delete edits[field];
        });

        edits.targeting_locked = true;

        model.save(edits, {
            contentType: 'application/json',
            patch: true,
            success: function(model, response) {
                model.unset('budget_adjustment_other_text');
                model.unset('budget_adjustment_select');
                model.set('editing', false);
                CampaignChannel.trigger('edit:campaign:success', model);
            },
            error: function(model, response) {
                // TODO: This is a code smell.  Our request should properly call the right method.
                if (response.status === 201) { // created
                    CampaignChannel.trigger('edit:campaign:success', model);
                } else {
                    CampaignChannel.trigger('edit:campaign:error', response);
                }
            }
        });
    }
}).bind(this);

var editSuccess = function(model) {
    CampaignChannel.trigger('details:show', model.get('initiative_id'), model.get('id'));
};

// TODO: Delete this or make it useful.
var editError = function() {
    // currentView.triggerMethod('Error'); // Pass in responseText, when backend changes it to user friendly messages.
};

CampaignChannel.on('edit:campaign:save',    editCampaign);
CampaignChannel.on('edit:campaign:success', editSuccess);
CampaignChannel.on('edit:campaign:error',   editError);

module.exports = Edit;
