import _ from 'underscore'
import Backbone from 'backbone'
import {Entity} from 'advisor/entities/advisor/creativeupload'
import {Entities} from 'advisor/entities/advisor/creativeupload'

describe('Creative Upload', () => {
    describe('Entity', () => {
        it('should exist', () => {
            expect(Entity).toBeDefined()
        })

        it('should be a Backbone Model', () => {
            expect(new Entity instanceof Backbone.Model).toBe(true)
        })
    })

    describe('Entities', () => {
        it('should exist', () => {
            expect(Entities).toBeDefined()
        })

        it('should be a Backbone Collection', () => {
            expect(new Entities instanceof Backbone.Collection).toBe(true)
        })

        it('should set passed in filter options directly on the collection', () => {
            let collection = new Entities([], {
                filters: {
                    id__in: 'abc,123',
                    limit: 2
                }
            })

            expect(collection.filters).toBeDefined()
            expect(collection.filters.id__in).toMatch(/abc,123/)
            expect(collection.filters.limit).toEqual(2)
        })

        describe('#isUploadComplete', () => {
            it('should return falsy when the collection has a model who\'s `completed_date` property is `null`', () => {
                let collection = new Entities([
                    { completed_date: new Date() },
                    { completed_date: new Date() },
                    { completed_date: null       }
                ])

                expect(collection.isUploadComplete()).toBeFalsy()
            })

            it('should return truthy when the collection has a model who\'s `completed_date` property is *not* `null`', () => {
                let collection = new Entities([
                    { completed_date: new Date() },
                    { completed_date: new Date() },
                    { completed_date: new Date() }
                ])

                expect(collection.isUploadComplete()).toBeTruthy()
            })
        })

        describe('#isUploadSuccessful', () => {
            it('should return falsy when the collection has a model who\'s `completed_date` property is `null`', () => {
                let collection = new Entities([
                    { completed_date: new Date() },
                    { completed_date: new Date() },
                    { completed_date: null       }
                ])

                expect(collection.isUploadSuccessful()).toBe(false)
            })

            it('should return truthy when the collection has a model who\'s `completed_date` property is *not* `null`' +
               ' and it\'s `status` property is \'FAILED\'', () => {
                let collection1 = new Entities([
                    { completed_date: new Date(), status: 'FAILED'  },
                    { completed_date: new Date(), status: 'SUCCESS' },
                    { completed_date: null,       status: 'SUCCESS' }
                ])

                expect(collection1.isUploadSuccessful()).toBe(false)

                let collection2 = new Entities([
                    { completed_date: new Date(), status: 'SUCCESS' },
                    { completed_date: new Date(), status: 'SUCCESS' },
                    { completed_date: null,       status: 'FAILED'  }
                ])

                expect(collection2.isUploadSuccessful()).toBe(false)
            })

            it('should return truth when the collection\'s `completed_date` property is *not* `null` and it\'s' +
               ' status is *not* \'FAILED\'', () => {
                let collection = new Entities([
                    { completed_date: new Date(), status: 'PAUSED'    },
                    { completed_date: new Date(), status: 'COMPLETED' },
                    { completed_date: new Date(), status: 'SUCCESS'   }
                ])

                expect(collection.isUploadSuccessful()).toBe(true)
            })
        })

        describe('#getFailedPostCount', () => {
            it('should return false when there are no models with a status uf \'FAILED\'', () => {
                let collection = new Entities([
                    { status: 'FAILED'  },
                    { status: 'FAILED'  },
                    { status: 'SUCCESS' },
                    { status: 'FAILED'  }
                ])

                expect(collection.getFailedPostCount()).toEqual(3)
            })
        })

        describe('#pollForStatus', () => {
            it('should return a jQuery promise', () => {
                let collection = new Entities([
                    { completed_date: new Date(), status: 'PAUSED'    },
                    { completed_date: new Date(), status: 'COMPLETED' },
                    { completed_date: new Date(), status: 'SUCCESS'   }
                ])

                // TODO: Create a `.toBeAPromise()` custom matcher.
                let isAPromise = _.isFunction(collection.pollForStatus().then)

                expect(isAPromise).toBe(true)
            })

            describe('on success', () => {
                beforeEach(() => {
                    spyOn(Backbone.Collection.prototype, 'fetch').and.callFake(function(options) {
                        options.success(this)
                    })
                })

                it('should resolve the promise', () => {
                    spyOn(Entities.prototype, 'stopPollingForStatus')
                    spyOn(Entities.prototype, 'isUploadComplete').and.returnValue(true)

                    let collection = new Entities([
                        { completed_date: new Date(), status: 'PAUSED'    },
                        { completed_date: new Date(), status: 'COMPLETED' },
                        { completed_date: new Date(), status: 'SUCCESS'   }
                    ])

                    let promise = collection.pollForStatus()

                    expect(promise.state()).toMatch(/resolved/)
                })

                it('should call #stopPollingForStatus if `entities.isUploadComplete()` returns truthy', () => {
                    spyOn(Entities.prototype, 'stopPollingForStatus')
                    spyOn(Entities.prototype, 'isUploadComplete').and.returnValue(true)

                    let collection = new Entities([
                        { completed_date: new Date(), status: 'PAUSED'    },
                        { completed_date: new Date(), status: 'COMPLETED' },
                        { completed_date: new Date(), status: 'SUCCESS'   }
                    ])

                    collection.pollForStatus()

                    expect(collection.stopPollingForStatus.calls.count()).toEqual(1)
                })

                it('should set a `pollTimeout` property that is a `setTimeout` on the collection ' +
                   'if `entities.isUploadComplete()` returns truthy', () => {
                    spyOn(Entities.prototype, 'isUploadComplete').and.returnValue(false)

                    let collection = new Entities([
                        { completed_date: new Date(), status: 'PAUSED'    },
                        { completed_date: new Date(), status: 'COMPLETED' },
                        { completed_date: new Date(), status: 'SUCCESS'   }
                    ])

                    expect(typeof collection.pollTimeout).toMatch(/undefined/)

                    collection.pollForStatus()

                    expect(typeof collection.pollTimeout).toMatch(/number/)

                    clearTimeout(collection.pollTimeout)
                })
            })

            describe('on error', () => {
                beforeEach(() => {
                    spyOn(Backbone.Collection.prototype, 'fetch').and.callFake(function(options) {
                        options.error(this, { responseText: 'Oh no!' })
                    })
                })

                it('should call #stopPollingForStatus', () => {
                    spyOn(Entities.prototype, 'stopPollingForStatus')

                    let collection = new Entities([
                        { completed_date: new Date(), status: 'PAUSED'    },
                        { completed_date: new Date(), status: 'COMPLETED' },
                        { completed_date: new Date(), status: 'SUCCESS'   }
                    ])

                    collection.pollForStatus()

                    expect(collection.stopPollingForStatus.calls.count()).toEqual(1)
                })

                it('should reject the promise', () => {
                    let collection = new Entities([
                        { completed_date: new Date(), status: 'PAUSED'    },
                        { completed_date: new Date(), status: 'COMPLETED' },
                        { completed_date: new Date(), status: 'SUCCESS'   }
                    ])

                    let promise = collection.pollForStatus()

                    expect(promise.state()).toMatch(/rejected/)
                })
            })
        })

        describe('#stopPollingForStatus', () => {
            it('should clear the `pollTimeout` property if there is one', (done) => {
                let collection = new Entities([])

                collection.fruit = 'orange'
                collection.pollTimeout = setTimeout(() => {
                    collection.fruit = 'banana'
                }, 500) // Half a second.  More than enough time.

                expect(collection.fruit).toMatch(/orange/,
                    'A dumb test just to ensure that we indeed set a property of \'fruit\' on the collection and ' +
                        'set it to \'orange\'. The real test is below.')

                collection.stopPollingForStatus()

                setTimeout(() => {
                    expect(collection.fruit).toMatch(/orange/,
                        '\'fruit\' should still be \'orange\' because we called #stopPollingForStatus which cleared ' +
                            'our `pollTimeout` property which set \'fruit\' to \'banana\' after half-a-second')
                    done()
                }, 510)
            })
        })
    })
})
