import _ from 'underscore'
import Backbone from 'backbone'
import AppChannel from 'advisor/app-channel'
import Base from 'advisor/entities/base'
import TastypiePageableCollection from 'advisor/config/TastypiePageableCollection'
import Picky from 'backbone.picky'

describe('Creative Entities', () => {
    describe('advisor:creative:entity', () => {
        beforeEach(() => {
            spyOn(Base, 'fetchEntity').and.callFake((Class, id) => {
                return new Class({ id: id })
            })
        })

        describe('on', () => {
            let model

            beforeEach(() => {
                // Intentionally spying on these guys a little bit above the scope their used at
                // so that we don't have to define the model in each it block.
                spyOn(Picky.Selectable.prototype, 'select')
                spyOn(Picky.Selectable.prototype, 'deselect')

                model = AppChannel.request('advisor:creative:entity', 15)
            })

            it('selected', () => {
                // Intentionally setting this silently so we do not trigger the change event.
                model.set('_selected', 'bar', { silent: true })

                expect(model.get('_selected')).toMatch(/bar/)

                model.selected = 'foo'
                model.trigger('selected')

                expect(model.get('_selected')).toMatch(/foo/)
            })

            it('deselected', () => {
                // Intentionally setting this silently so we do not trigger the change event.
                model.set('_selected', 'bar', { silent: true })

                expect(model.get('_selected')).toMatch(/bar/)

                model.selected = 'foo'
                model.trigger('selected')

                expect(model.get('_selected')).toMatch(/foo/)
            })

            describe('change of `_selected`', () => {
                it('if `_selected` is truthy it calls #select', () => {
                    model.set('_selected', 'baz')

                    expect(model.select.calls.count()).toEqual(1)
                    expect(model.deselect.calls.count()).toEqual(0)
                })

                it('if `_selected` is falsy it calls #deselect', () => {
                    model.set('_selected', null)

                    expect(model.select.calls.count()).toEqual(0)
                    expect(model.deselect.calls.count()).toEqual(1)
                })
            })
        })

        describe('on request for an entity', () => {
            it('fetch should only be called once', () => {
                AppChannel.request('advisor:creative:entity', 15)
                expect(Base.fetchEntity.calls.count()).toEqual(1)
            })

            it('should return the requested model', () => {
                expect(AppChannel.request('advisor:creative:entity', 15).get('id')).toEqual(15)
            })
        })
    })

    describe('advisor:creative:entities', () => {
        beforeEach(() => {
            spyOn(Base, 'fetchEntities').and.callFake((Class) => {
                return new Class()
            })
        })

        it('fetch should only be called once', () => {
            AppChannel.request('advisor:creative:entities')
            expect(Base.fetchEntities.calls.count()).toEqual(1)
        })

        it('should return the correct instance of the requested collection', () => {
            let Collection = AppChannel.request('advisor:creative:Entities')
            let collection = AppChannel.request('advisor:creative:entities')

            expect(collection instanceof Collection).toBe(true)
        })
    })

    describe('advisor:creative:Entity', () => {
        it('should return a Backbone Model Class', () => {
            let Model = AppChannel.request('advisor:creative:Entity')

            expect(new Model instanceof Backbone.Model).toBe(true)
        })
    })

    describe('advisor:creative:Entities', () => {
        it('should return a Backbone Collection Class', () => {
            let Collection = AppChannel.request('advisor:creative:Entities')

            expect(new Collection instanceof Backbone.Collection).toBe(true)
        })
    })
})
