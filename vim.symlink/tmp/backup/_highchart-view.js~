// TODO: Remove the underscore from the front of this filename once we have a proper import solution.
// TODO: This "base" chart is getting a little too specific. Should break out into smaller extended chunks soon.
AdvisorApp.module('Common.Views', function(Views) {
    Views.HighchartView = Marionette.LayoutView.extend({
        template: Handlebars.templates.Chart,

        defaultOptions: {
            /** Query Params in collection fetch URL */
            collectionFilters: null,
            // TODO: Grab this from element on the page that shares same value so if and when the styleguide is update
            // so is this!
            /** Default chart colors */
            colors: ['#2FA580'],
            /** Default metric from collection's models to graph in chart. */
            metric: 'kpi',
            showToolbar: false
        },

        /** Chart will not render until loading is set to false. */
        loading: true,

        /*
          The chartRegion isn't used in a traditional Marionette.LayoutView way here. I could get away without
          defining it here at all. However I am defining it to illustrate to you, dear reader, that we are rendering
          two regions in this view. The toolbarRegion is rendered in the normal way. The chartRegion is not.
          It is passed as the el on the Highcharts options object. Again, defining here is merely semnatic.
        */
        regions: {
            chartRegion: '.highchart',
            toolbarRegion: '.chart-toolbar'
        },

        initialize: function(options) {
            this.options      = this.getOptions(options);
            this.chartToolbar = new Views.ChartToolbar(this.getChartToolbarOptions());

            this.bindEventListeners();
            this.fetchCollection();
        },

        /**
         * @param {Object} options
         * @returns {Object}
         */
        getOptions: function(options) {
            return _.defaults(options || {}, this.defaultOptions);
        },

        /**
         * @returns {Object}
         */
        getChartToolbarOptions: function() {
            return {
                metric: this.options.metric,
                parentView: this,
                platform: this.options.platform,
                showDateRangePicker: true,
                showMetricPicker: true,
                startDate: this.options.startDate,
                endDate: this.options.endDate,
                campaign: this.options.campaign,
                showCustomReport: this.options.showCustomReport
            };
        },

        bindEventListeners: function() {
            var triggerChangeMetric    = _.bind(this.trigger, this, 'changeMetric');
            var triggerChangeDateRange = _.bind(this.trigger, this, 'changeDateRange');
            var triggerError           = _.bind(this.trigger, this, 'error');

            this.listenTo(this.chartToolbar, 'changeMetric',    triggerChangeMetric);
            this.listenTo(this.chartToolbar, 'changeDateRange', triggerChangeDateRange);
            this.listenTo(this.chartToolbar, 'error',           triggerError);

            this.on('changeMetric',    this.changeMetric,    this);
            this.on('changeDateRange', this.changeDateRange, this);
        },

        /**
         * @returns {Backbone.View} this
         */
        onShow: function() {
            this.createChartForMetric();

            if (this.options.showToolbar) {
                this.toolbarRegion.show(this.chartToolbar);
            }

            return this;
        },

        /**
         * @param {Object} options
         */
        createChartForMetric: function(options) {
            this.chart = new Highcharts.Chart(this.getHighchartsOptions(options));
            this.chart.showLoading('Loading data...');
        },

        /**
         * @param {Object|undefined} options for Highcharts. Only passed in if we actually have series data yet.
         * If still loading then nothing is passed in.
         * @returns {Object} of highcharts options.
         */
        getHighchartsOptions: function(options) {
            var baseOptions = {
                colors: this.options.colors,
                chart: {
                    type: 'column',
                    /*
                      At this point this view's template is not attached to the DOM so we need to use Backbone's
                      scoped jQuery selector to access the not-yet-attached-to-the-DOM element for the
                      #renderTo property.
                    */
                    renderTo: this.$(this.chartRegion.el).get(0),
                    height: 300
                },
                exporting: {
                    enabled: false
                },
                credits: {
                    enabled: false
                },
                legend: {
                    enabled: false
                },
                yAxis: {
                    min: 0,
                    maxPadding: 0.05,
                    endOnTick: true,
                    title: null
                },
                xAxis: {
                    type: 'datetime',
                    labels: {
                        overflow: 'justify'
                    }
                },
                plotOptions: {
                    series: {
                        marker: {
                            enabled: false
                        },
                        lineWidth: 1.9,
                        states: {
                            hover: {
                                lineWidth: 1.9
                            }
                        }
                    }
                },
                title: null,
                series: []
            };

            options = options || {};

            return $.extend(true, baseOptions, options);
        },

        /**
         * @param {$.Event} metric from the click event.
         */
        changeMetric: function(metric) {
            this.options.metric = metric;

            this.drawChart();
        },

        /**
         * @param {String} event
         * @param {Object} dates
         */
        changeDateRange: function(dateRanges) {
            var startDate = this.getDateString(dateRanges.startDate);
            var endDate   = this.getDateString(dateRanges.endDate);

            /** If the date range is the same that's already selected then don't re-fetch */

            /**
             * PLATFORM DEPENDECY CHECK
             * Twitter charts need the start parameter returned as 'start__gte' & 'start__lte'
             * Would be nice to update one of the endpoints so that we can use the same code here.
             */
            if (this.options.platform === 'facebook') {
                if (this.options.collectionFilters.date_start__gte === startDate &&
                    this.options.collectionFilters.date_start__lte === endDate) {
                    return;
                }

                this.options.collectionFilters.date_start__gte = startDate;
                this.options.collectionFilters.date_start__lte = endDate;
            } else {
                if (this.options.collectionFilters.start__gte === startDate &&
                    this.options.collectionFilters.start__lte === endDate) {
                    return;
                }

                this.options.collectionFilters.start__gte = startDate;
                this.options.collectionFilters.start__lte = endDate;
            }

            this.fetchCollection();
        },

        /**
         * @param {Moment|String} date
         * @returns {String}
         */
        getDateString: function(date) {
            var format = this.options.format || 'YYYY-MM-DD';
            return moment.isMoment(date) ? date.format(format) : moment(date).format(format);
        },

        fetchCollection: function() {
            var startDate;
            var endDate;

            this.loading = true;

            /**
             * PLATFORM DEPENDECY CHECK
             * Twitter charts need the start parameter returned as 'start__gte' & 'start__lte'
             * Would be nice to update one of the endpoints so that we can use the same code here.
             */
            if (this.options.platform == 'facebook') {
                /**
                 * If we do not have a start and end date on the collectionFilters then these are the defaults. This is
                 * clearly a kind of gross bandaid. Would LOVE to kill this code soon.
                 */
                if (!this.options.collectionFilters.date_start__gte && !this.options.collectionFilters.date_start__lte) {
                    this.options.collectionFilters.date_start__gte = moment().startOf('day').subtract(7, 'days');
                    this.options.collectionFilters.date_start__lte = moment().endOf('day');
                }

                /**
                 * If the collectionFilters's start and end dates aren't strings then convert them to strings.
                 */
                if (!_.isString(this.options.collectionFilters.date_start__gte) ||
                    !_.isString(this.options.collectionFilters.date_start__lte)) {
                    this.options.collectionFilters.date_start__gte =
                        this.getDateString(this.options.collectionFilters.date_start__gte);
                    this.options.collectionFilters.date_start__lte =
                        this.getDateString(this.options.collectionFilters.date_start__lte);
                }
            } else {
                /**
                 * If we do not have a start and end date on the collectionFilters then these are the defaults. This is
                 * clearly a kind of gross bandaid. Would LOVE to kill this code soon.
                 */
                if (!this.options.collectionFilters.start__gte && !this.options.collectionFilters.start__lte) {
                    this.options.collectionFilters.start__gte = moment().startOf('day').subtract(7, 'days');
                    this.options.collectionFilters.start__lte = moment().endOf('day');
                }

                /**
                 * If the collectionFilters's start and end dates aren't strings then convert them to strings.
                 */
                if (!_.isString(this.options.collectionFilters.start__gte) ||
                    !_.isString(this.options.collectionFilters.start__lte)) {
                    this.options.collectionFilters.start__gte =
                        this.getDateString(this.options.collectionFilters.start__gte);
                    this.options.collectionFilters.start__lte =
                        this.getDateString(this.options.collectionFilters.start__lte);
                }
            }

            this.collection.fetch({
                data: this.options.collectionFilters,
                success: _(this.onFetchSuccess).bind(this),
                /*
                   When the model data returns from the server, it uses set to (intelligently) merge the fetched
                   models, unless you pass `{reset: true}`, in which case the collection will be (efficiently) reset.
                 */
                reset: true,
                cache: false
            });
        },

        /**
         * @param {Backbone.Collection} collection returned from server
         * @param {Object} response from server
         * @param {Object} options passed to fetch request
         */
        onFetchSuccess: function(collection, response, options) {
            this.loading = false;

            /**
             * @param {Backbone.Model} model
             */
            collection.each(function(model) {
                model.set(this.setOnSuccess(model));
            }, this);

            this.drawChart();
        },

        drawChart: function() {
            /** Human readable metric name mapping for the chart. */
            var nameMapping = {
                app_clicks:         'App Clicks',
                app_engagements:    'App Engagements',
                clicks:             'Clicks',
                engagements:        'Engagements',
                engagement_rate:    'Engagement Rate',
                impressions:        'Impressions',
                kpi:                'KPI',
                kpi_primary_events: 'Results',
                kpi_primary_spend:  'Spend',
                spend:              'Spend'
            };
            var options = {};

            options.series = [];
            options.series.push({
                name: nameMapping[this.options.metric],
                data: this.collection.getHighchartsSeriesData(this.options.metric, this.options.platform)
            });

            /** Give special attention to monetary metrics. */
            if (_.contains(['kpi', 'kpi_primary_spend', 'spend'], this.options.metric)) {
                // NOTE: Using extend rather than direct assignment because less change of overriding desired options.
                $.extend(true, options, {
                    yAxis: {
                        labels: {
                            formatter: function() {
                                return '$' + this.axis.defaultLabelFormatter.call(this);
                            }
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            return Highcharts.dateFormat('%a %d %b', this.point.x) +
                                '<br /><b>' + this.point.series.name + '</b>: ' + accounting.formatMoney(this.point.y);
                        }
                    }
                });
            }

            /** Give special attention to percentage metrics. */
            if (_.contains(['engagement_rate'], this.options.metric)) {
                // NOTE: Using extend rather than direct assignment because less change of overriding desired options.
                $.extend(true, options, {
                    yAxis: {
                        labels: {
                            formatter: function() {
                                return this.axis.defaultLabelFormatter.call(this) + '%';
                            }
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            return Highcharts.dateFormat('%a %d %b', this.point.x) +
                                '<br /><b>' + this.point.series.name + '</b>: ' + (this.point.y).toFixed(2) + '%';
                        }
                    }
                });
            }

            this.createChartForMetric(options);
            this.chart.hideLoading();
        }
    });
});
