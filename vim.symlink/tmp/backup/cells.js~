/* global dependencies */
var numeral = require('numeral');
var Backbone = require('backbone');
var $ = require('jquery');
var moment = require('moment-timezone');
var accounting = require('accounting');
var _ = require('underscore');
var _string = require('underscore.string');
var Backgrid = require('backgrid');
var AppChannel = require('advisor/app-channel');

// TODO: preferably this would return the objects it decorates to Extension so we can use them directly. ~jd
require('backgrid-select-all');
var SelectRowCell = Backgrid.Extension.SelectRowCell;

require('bootstrap-datepicker');
require('timepicker');

var Helpers = require('../../config/helpers');

/* templates */
var SCBidEditCellTemplate = require('advisor/common/templates/SCBidEditCell.hbs');
var SCDropdownCellTemplate = require('advisor/common/templates/SCDropdownCell.hbs');
var SCInlineEditCellTemplate = require('advisor/common/templates/SCInlineEditCell.hbs');
var SCDateTimeEditCellFormTemplate = require('advisor/common/templates/SCDateTimeEditCellForm.hbs');
var SCPinterestDateEditCellFormTemplate = require('advisor/common/templates/SCPinterestDateEditCellForm.hbs');
var SCBudgetCellTemplate = require('advisor/common/templates/SCBudgetCell.hbs');
var SCAdPreviewCellTemplate = require('advisor/common/templates/SCAdPreviewCell.hbs');
var SCTotalSpendCellTemplate = require('advisor/common/templates/SCTotalSpendCell.hbs');
var SCSelectAllActionHeaderCellTemplate = require('advisor/common/templates/SCSelectAllActionHeaderCell.hbs');
var SCClickToCopyCellTemplate = require('advisor/common/templates/SCClickToCopyCell.hbs');
var SCActionDropdownCellTemplate = require('advisor/common/templates/SCActionDropdownCell.hbs');
var creativemodalTemplate = require('advisor/modules/creative/templates/creativemodal.hbs');
var facebookpreviewTemplate = require('advisor/modules/creative/templates/facebookpreview.hbs');
var twitterpreviewTemplate = require('advisor/modules/creative/templates/twitterpreview.hbs');
var SCObjectBrowserButtonGroupCellTemplate = require('advisor/common/templates/SCObjectBrowserButtonGroupCell.hbs');
var CampaignDuplicateAdClusterModal = require('advisor/modules/campaign/templates/CampaignDuplicateAdClusterModal.hbs');
var CampaignDeleteAdClusterModal = require('advisor/modules/campaign/templates/CampaignDeleteAdClusterModal.hbs');

/* local dependencies */
var CommonLanguage = require('advisor/common/language');

(function() {
    // Common functions
    var error = function(resp, xhr) {
        var errorMessage = (function findStringInObject(obj, defaultString) {
            if (typeof obj === 'string') return obj;
            if (!obj || !_.isObject(obj) || _.keys(obj) === 0) return defaultString;
            return findStringInObject(_.values(obj)[0], defaultString);
        })(xhr.responseJSON, xhr.responseText);
        AppChannel.trigger('alert', {
            message: _string.humanize(errorMessage),
            type: 'danger'
        });

        this.model.trigger('backgrid:force-reset');
    };

    var success = function() {
        this.model.trigger('backgrid:force-reset');
    };

    // Default cells to not editable
    Backgrid.Column.prototype.defaults.editable = false;
    Backgrid.Column.prototype.defaults.hideable = true;
    Backgrid.Column.prototype.defaults.disabled = false;
    Backgrid.Column.prototype.defaults.defaultColumn = false;
    Backgrid.Column.prototype.defaults.sortType = 'toggle';
    Backgrid.Column.prototype.defaults.aggregationColumns = 'all';

    /**
     * @returns {Boolean} If true then cell is editable, if false then it is not editable.
     */
    Backgrid.Cell.prototype.isEditable = function() {
        // NOTE: In a perfect world we'd always check for user editable permissions, however to make this a little-bit
        //       bulletproof with previous code I'm allowing for this block to be skipped over if a
        //       #userCanManage method does not exist on the model.
        if (_.isFunction(this.model.userCanManage) && !this.model.userCanManage() ||
            !this.model.userCanManage ||
            !this.model.getEditableCells) {
            return false;
        }

        var allColumns = this.column.collection.pluck('name');
        var editableCells = this.model.getEditableCells(allColumns);
        var cellName = this.column.get('name');
        var isEditable = _(editableCells).indexOf(cellName) !== -1;

        // If this method is being invoked from a Backgrid Cell with a isValueEditable method on it and isEditable
        // is true then run the isValueEditable method and the result of that will determine if the cell is edtaible.
        // Otherwise simply return the current value of isEditable.
        if (isEditable && this.isValueEditable) {
            isEditable = this.isValueEditable();
        }

        return isEditable;
    };

    /**
     * @returns {Boolean} If the cell's isEditable method returns true and the user has the correct permissions
     * then this method returns true meaning editing is enabled, otherwise it returns false meaning editing is disabled.
     */
    Backgrid.Cell.prototype.editingEnabled = function() {
        return this.isEditable();
    };

    // Formatters
    var CurrencyFormatter = Backgrid.Extension.CurrencyFormatter = function(options) {
        _.extend(this, this.defaults, options || {});
    };
    CurrencyFormatter.prototype = new Backgrid.NumberFormatter();
    _.extend(CurrencyFormatter.prototype, {
        // Default settings for accounting.js
        // TODO: DRY up with other implementations of this same section.
        symbol: '$',
        decimal: '.',
        thousand: ',',
        precision: 2,
        format: '%s%v',

        defaults: {
            divider: 1
        },

        // Takes attribute value and formats for display to user
        fromRaw: function(value, model) {
            value = value / this.divider;

            return accounting.formatMoney(value, {
                symbol: this.symbol,
                decimal: this.decimal,
                thousand: this.thousand,
                precision: this.precision,
                format: this.format
            });
        },

        // Takes human input and prepares to be set back to the model
        toRaw: function(formattedValue, model) {
            // Remove all but digits and periods
            return accounting.unformat(formattedValue);
        }
    });

    var SCStringToIntegerFormatter = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue) {
            return Backgrid.NumberFormatter.prototype.fromRaw.call(this, parseInt(rawValue));
        }
    });

    var SCCurrencyFormatter = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue, model) {
            if (!Helpers.valueIsValid(rawValue)) {
                return '-';
            }
            return accounting.formatMoney(rawValue);
        },

        toRaw: function(formattedValue, model) {
            return Backgrid.NumberFormatter.prototype.toRaw.call(this, formattedValue.substring(1));
        }
    });

    var MicrodollarFormatter = Backgrid.Extension.MicrodollarFormatter = function(options) {
        _.extend(this, this.defaults, options || {});
    };

    MicrodollarFormatter.prototype = new Backgrid.NumberFormatter();

    _.extend(MicrodollarFormatter.prototype, {
        currencyPrefix: '$',
        currencySuffix: '',

        // Takes attribute value and formats for display to user
        fromRaw: function(number, model) {
            number = number || 0;
            number = (number / 1000000.0).toFixed(~~this.decimals);
            var parts = number.split('.');
            var integerPart = parts[0];
            var decimalPart = parts[1] ? '.' + parts[1] : '';

            return this.currencyPrefix +
                integerPart.replace(this.HUMANIZED_NUM_RE, '$1' + this.orderSeparator) +
                decimalPart +
                this.currencySuffix;
        },

        // Takes human input and prepares to be set back to the model
        toRaw: function(formattedData, model) {
            // Remove all but digits and periods
            var rawData = formattedData.replace(/[^\d.]/g, '');
            var result = (rawData * 1).toFixed(~~this.decimals) * 1;

            if (_.isNumber(result) && !_.isNaN(result)) {
                return result * 1000000;
            }
        }
    });

    var SCBudgetFormatter = Backgrid.Extension.SCBudgetFormatter = function(options) {
        _.extend(this, this.defaults, options || {});
    };

    SCBudgetFormatter.prototype = new Backgrid.StringFormatter();

    _.extend(SCBudgetFormatter.prototype, {
        // Default settings for accounting.js
        // TODO: DRY up with other implementations of this same section.
        format: {
            symbol: '$',
            decimal: '.',
            thousand: ',',
            precision: 2,
            format: '%s%v'
        },

        // Takes attribute value and formats for display to user
        fromRaw: function(value, model) {
            var label = 'Lifetime';

            value = model.get('lifetime_budget') / 100.0;

            // Switch label to daily if there's no lifetime
            if (value === 0) {
                value = model.get('daily_budget') / 100.0;
                label = 'Daily';
            }

            return accounting.formatMoney(value, this.format) + '<br /><small>' + label + '</small>';
        },

        // Takes human input and prepares to be set back to the model
        toRaw: function(formattedValue, model) {
            // Remove all but digits and periods, multiply by 100
            return accounting.unformat(formattedValue) * 100;
        }
    });

    var SCDateFormatter = Backgrid.Extension.SCDateFormatter = function(options) {
        _.extend(this, this.defaults, options || {});
    };
    SCDateFormatter.prototype = new Backgrid.StringFormatter();

    _.extend(SCDateFormatter.prototype, {
        // Takes attribute value and formats for display to user
        fromRaw: function(value, model) {
            var dateTime = moment.utc(value).tz(this.timezone);
            var content = '';

            if (value && dateTime.isValid()) {
                content = dateTime.format('M/D/YY <br /> <\\s\\m\\a\\l\\l>h:mma z</\\s\\m\\a\\l\\l>');
            } else {
                content = '<small>N/A</small>';
            }

            return '<div class="pull-left">' + content + '</div>';
        }
    });

    var SCPinterestDateFormatter = Backgrid.Extension.SCPinterestDateFormatter = function(options) {
        _.extend(this, this.defaults, options || {});
    };
    SCPinterestDateFormatter.prototype = new Backgrid.StringFormatter();

    _.extend(SCPinterestDateFormatter.prototype, {
        // Takes attribute value and formats for display to user
        fromRaw: function(value, model) {
            return '<div class="pull-left">' +  moment(value).format('M/D/YY') + '</div>';
        }
    });

    // Cells
    var LinkCell = Backgrid.Extension.LinkCell = Backgrid.StringCell.extend({
        linkUri: function() {
            return '#';
        },

        render: function() {
            var value = this.formatter.fromRaw(this.model.get(this.column.get('name')));

            // Allow lines to break on underscores
            value = value.replace(/_/g, '_&#8203;');

            var link = $('<a>', {
                href: this.linkUri(),
                text: value
            });

            this.$el.html(link);
            this.delegateEvents();

            return this;
        }
    });

    var AdClusterLinkCell = Backgrid.Extension.AdClusterLinkCell = Backgrid.StringCell.extend({
        linkUri: function() {
            return '#';
        },

        render: function() {
            var value = this.formatter.fromRaw(this.model.get(this.column.get('name')));

            var link = _.isEmpty(this.linkUri()) ?
                        value :
                        $('<a>', {
                            href: this.linkUri(),
                            text: value
                        });

            this.$el.html(link);
            this.delegateEvents();

            return this;
        }
    });

    var SCEngagementCountCell = Backgrid.Extension.SCEngagementCountCell = Backgrid.IntegerCell.extend({
        formatter: SCStringToIntegerFormatter
    });

    var SCEditableStatusCell = Backgrid.Extension.SCEditableStatusCell = Backgrid.StringCell.extend({
        template: SCDropdownCellTemplate,

        events: {
            'click a.sc-dropdown-edit': 'itemClicked'
        },

        alignment: 'right',

        startSpinner: function() {
            this.$('i.fa.fa-status').attr('class', 'fa fa-fw fa-status fa-spinner fa-spin');
        },

        render: function() {
            var value        = this.model.get(this.column.get('name'));
            var status       = this.formatter.fromRaw(value, this.model).toLowerCase();
            var status_class = 'fa-status-' + status.replace('_', '-');
            var status_label = status.replace('_', ' ');
            var status_icon  = '<i class="fa fa-fw fa-status ' + status_class + '" title="' + status_label + '"></i>';

            this.$el.addClass('sc-editable-status-cell').html(this.template({
                editingEnabled: this.editingEnabled(),
                value: status_icon,
                choices: this.model.getStatusActions(),
                attributeName: this.column.get('name'),
                alignment: this.alignment
            }));

            this.delegateEvents();

            return this;
        },

        itemClicked: function(e) {
            var target = $(e.currentTarget);
            var value = target.data('value');
            var objectData = {};

            success = function() {
                /**
                 * Currently, the database does not return the updated object(s) in bulk action
                 * responses, so we need to fetch the collection to display any updates.  If
                 * that should change down the road, this fetch() can be replaced with: this.render().
                 * Access to the collection is by the 'gridCollection' callback passed in when the cell is created.
                 */
                this.gridCollection().fetch();
            };

            objectData[this.column.get('name')] = this.formatter.toRaw(value);

            this.startSpinner();

            $.ajax({
                type: 'POST',
                contentType: 'application/json',
                url: '/api/advisor/v1/campaign/' + value + '/',
                data: JSON.stringify({
                    'id__in': this.model.get('id')
                }),
                success: _(success).bind(this),
                error: _(error).bind(this)
            });

            this.$('.dropdown').dropdown('toggle');

            return false;
        }
    });

    var SCStatusCell = Backgrid.Extension.SCStatusCell = Backgrid.StringCell.extend({
        className: 'sc-status-cell',

        render: function() {
            var value        = this.model.get(this.column.get('name')) || this.model.getStatus();
            var status       = this.formatter.fromRaw(value).toLowerCase();
            var status_class = 'fa-status-' + status.replace('_', '-');
            var status_label = status.replace('_', ' ');

            this.$el.html($('<i/>', {
                'class': 'fa fa-fw fa-status-' + status + ' ' + status_class,
                title: status_label
            }));

            this.delegateEvents();

            return this;
        }
    });

    var SCAdClusterStatusCell = Backgrid.Extension.SCAdClusterStatusCell = Backgrid.StringCell.extend({
        className: 'sc-status-cell',

        render: function() {
            var value        = this.model.get(this.column.get('name')) || this.model.getStatus();
            var status       = this.formatter.fromRaw(value).toLowerCase();
            var status_class = status === 'pending' ?
                'fa-status-' + status + ' fa-rotate-270 sc-ad-cluster-status' :
                'fa-status-' + status + ' sc-ad-cluster-status';

            this.$el.html($('<i/>', {
                'class': 'fa fa-fw ' + status_class,
                title: status
            }));

            this.delegateEvents();

            return this;
        }
    });

    var SCInlineEditCell = Backgrid.Extension.SCInlineEditCell = Backgrid.Cell.extend({
        events: {
            'click .popover-trigger': 'togglePopover',
            'click a.sc-edit-detail': 'linkClicked'
        },

        form: SCInlineEditCellTemplate,

        placement: 'left',

        startSpinner: function() {
            this.$('i.fa-pencil').removeClass('fa-pencil').addClass('fa-spinner fa-spin');
        },

        render: function() {
            var value    = this.formatter.fromRaw(this.model.get(this.column.get('name')), this.model);
            var editLink = $('<div/>').addClass('sc-edit-link');

            // Intentionally emptying here because we could end up in an inbetween state if we do not.
            this.$el.empty().addClass('sc-inline-edit-cell');

            if (_.isFunction(this.form)) {
                this.form = this.form();
            }

            // TODO: Abstract this whole block out into several methods and/or templates. Way too much going on here.
            if (!_.isNull(value)) {
                // Preserve detail links, make pencil the only click target
                if (this.linkUri) {
                    // Allow lines to break on underscores
                    value = value.replace(/_/g, '_&#8203;');

                    editLink.append(
                        $('<a/>')
                        .attr('href', this.linkUri())
                        .addClass('sc-edit-detail')
                        .html(value)
                    );

                    if (this.editingEnabled()) {
                        editLink.append(
                            $('<a/>')
                            .addClass('popover-trigger')
                            .html('<i class="fa fa-pencil sc-edit-icon"></i>')
                        );
                    }
                    this.$el.append(editLink);
                } else {
                    var icon = '';

                    if (this.editingEnabled()) {
                        icon = '<i class="fa fa-pencil sc-edit-icon"></i>';
                    }

                    this.$el.append($('<span>')
                        .addClass('popover-trigger sc-edit-link')
                        .html(value + icon)
                    );
                }

                if (this.editingEnabled()) {
                    this.$('.sc-edit-link').addClass('enabled');

                    var popover = $(this.$('i.fa')).popover({
                        html: true,
                        content: this.form,
                        placement: this.placement,
                        trigger: 'manual'
                    });
                }
            } else {
                this.$el.append($('<span class="text-muted">').text('--'));
            }

            this.delegateEvents();

            return this;
        },

        prepareForm: function() {
            this.$('input').val(this.model.get(this.column.get('name'))).focus();
        },

        linkClicked: function(e) {
            return true;
        },

        togglePopover: function(e) {
            e.preventDefault();
            e.stopPropagation();

            if (this.$('div.popover').length === 0) {
                // Close any existing popovers on the page first
                $('i.fa.open').removeClass('open').popover('hide');
                $(this.$('i.fa').addClass('open')).popover('show');

                this.$('a.close').on('click', this.closePopover);
                this.$('form').on('submit', _(this.submit).bind(this));

                this.prepareForm();

                // Clicks outside of the popover should close it
                $(document).on('click', this.closePopover);
                this.$('.popover').off('click').on('click', function(e) {
                    e.stopPropagation(); // Prevent clicks inside from triggering document:click
                });
            } else {
                this.closePopover();
            }
        },

        closePopover: function(e) {
            /** Moved logic to handle clicks on date/time pickers here.
             * The overloaded method in the extended SCDateTimeEditCell wouldn't work correctly if
             * a different form had been open and closed before it.
             * Other popovers still work correctly.
             */
            if (e && !$(e.target).is('.day, .month, .year, .prev, .next, .datepicker, .datepicker-switch, .ui-timepicker-input, body, li')) {
                $('input.timepicker', this.el).timepicker('remove');
                $('input.datepicker', this.el).datepicker('remove');
                $('i.fa.open').popover('hide').removeClass('open');
            }
        },

        updateUri: function() {
            return this.model.url();
        },

        submit: function(e) {
            e.preventDefault();

            var inputControl = this.$('input').not('.editor-ignore');
            var newvalue     = inputControl.val();
            var attribute    = inputControl.data('attribute') || this.column.get('name');
            var changedData   = {};
            // Disables all form input fields inside of this template while we save
            this.$(':input').prop('disabled', true);
            changedData[attribute] = this.formatter.toRaw(newvalue);

            this.saveChanges(changedData);

        },

        saveChanges: function(changedData) {

            this.startSpinner();

            this.model.save(changedData, {
                silent: true,
                patch: true,
                success: _(success).bind(this),
                error: _(error).bind(this)
            });

            this.closePopover(null);
        }
    });

    var SCObjectBrowserEditCell = Backgrid.Extension.SCObjectBrowserEditCell = SCInlineEditCell.extend({
        /** Subclassed SCInlineEditCell to handle data payload preparation for the proxied endpoints used in object browser */
        saveChanges: function(changedData) {
            changedData.id = this.model.get('id');
            var objectData   = {
                updates: [changedData]
            };

            this.startSpinner();

            this.model.save(objectData, {
                url: this.updateUri(),
                silent: true,
                patch: true,
                success: _(success).bind(this),
                error: _(error).bind(this)
            });

            this.closePopover(null);
        }
    });

    var SCObjectBrowserStatusEditCell = Backgrid.Extension.SCObjectBrowserStatusEditCell = SCObjectBrowserEditCell.extend({
        template: SCDropdownCellTemplate,

        events: {
            'click a.sc-dropdown-edit': 'itemClicked'
        },

        alignment: 'right',

        startSpinner: function() {
            this.$('i.fa.fa-status').attr('class', 'fa fa-fw fa-status fa-spinner fa-spin');
        },

        render: function() {
            var value        = this.model.get(this.column.get('name'));
            var status       = this.formatter.fromRaw(value, this.model).toLowerCase();
            var status_class = 'fa-status-' + status.replace('_', '-');
            var status_label = status.replace('_', ' ');
            var status_icon  = '<i class="fa fa-fw fa-status ' + status_class + '" title="' + status_label + '"></i>';

            this.$el.addClass('sc-editable-status-cell').html(this.template({
                editingEnabled: this.editingEnabled(),
                value: status_icon,
                choices: this.statusActions || this.model.getStatusActions(),
                attributeName: this.column.get('name'),
                alignment: this.alignment
            }));

            this.delegateEvents();

            return this;
        },

        itemClicked: function(e) {
            this.saveChanges(e);
            this.$('.dropdown').dropdown('toggle');

            return false;
        },

        saveChanges: function(event) {
            var changedData  = {};
            var value        = $(event.currentTarget).data('value');
            var attribute    = this.column.get('name');

            changedData[attribute] = this.formatter.toRaw(value);
            changedData.id = this.model.get('id');
            var objectData   = {
                updates: [changedData]
            };

            this.startSpinner();

            this.model.save(objectData, {
                url: this.updateUri(),
                silent: true,
                patch: true,
                success: _(success).bind(this),
                error: _(error).bind(this)
            });

            this.closePopover(null);
        }
    });

    var SCTwitterStatusCell = Backgrid.Extension.SCTwitterStatusCell = SCObjectBrowserStatusEditCell.extend({
        render: function() {
            var status = this.model.getStatus();
            var status_class = 'fa-status-' + status;
            var status_label = status.replace('_', ' ');
            var status_icon  = '<i class="fa fa-fw fa-status ' + status_class + '" title="' + status_label + '"></i>';

            this.$el.addClass('sc-editable-status-cell').html(this.template({
                editingEnabled: this.editingEnabled(),
                value: status_icon,
                choices: this.statusActions || this.model.getStatusActions(),
                attributeName: this.column.get('name'),
                alignment: this.alignment
            }));

            this.delegateEvents();

            return this;
        },

        /** saveChanges is copied again becuase Twitter sends an attribute of 'paused' instead of the 'status' */
        saveChanges: function(changedData) {
            var value        = $('.sc-dropdown-edit').data('value');
            var attribute    = 'paused';

            changedData[attribute] = this.formatter.toRaw(value);
            changedData.id = this.model.get('id');
            var objectData   = {
                updates: [changedData]
            };

            this.startSpinner();

            this.model.save(objectData, {
                url: this.updateUri(),
                silent: true,
                patch: true,
                success: _(success).bind(this),
                error: _(error).bind(this)
            });

            this.closePopover(null);
        }
    });

    var SCDateTimeEditCell = Backgrid.Extension.SCDateTimeEditCell = SCInlineEditCell.extend({
        form: SCDateTimeEditCellFormTemplate,
        timezone: 'America/New_York',
        formatter: SCDateFormatter,
        dateFormat: 'YYYY-MM-DD[T]HH:mm:ssZZ',
        initialize: function(options) {
            SCDateTimeEditCell.__super__.initialize.apply(this, arguments);
            this.timezone = options.timezone || this.timezone;
            this.formatter.timezone = this.timezone;
        },

        daysDifference: function(date) {
            var timeDiff = Math.abs(moment().utc().tz(this.timezone) - moment(date).utc().tz(this.timezone));
            return Math.ceil(timeDiff / (1000 * 3600 * 24));
        },

        prepareForm: function() {
            var columnName    = this.column.get('name');
            this.$('.sc-datetime-form').addClass(columnName);
            var currentValue  = moment.utc(this.model.get(columnName)).tz(this.timezone);
            // var minDays       = this.daysDifference(this.start_date) - 1;
            // var maxDays       = this.daysDifference(this.end_date);
            var $hiddenWidget = this.$('#datetime_value');
            var $timeWidget   = this.$('input.timepicker');
            var $dateWidget   = this.$('input.datepicker');
            var timezone      = this.timezone;
            var dateFormat    = this.dateFormat;
            var updateDate;

            if (currentValue.isValid()) {
                $hiddenWidget.val(currentValue.toJSON());
                $timeWidget.val(currentValue.format('h:mma'));
                $dateWidget.val(currentValue.format('MM/DD/YYYY'));
            }

            $($dateWidget).datepicker({
                autoclose: true
                // endDate:   '+' + maxDays + 'd',
                // startDate: '-' + minDays + 'd'
            });
            $($timeWidget).timepicker();

            updateDate = function(e) {
                var dateString = $dateWidget.val() + ' ' + $timeWidget.val();
                var dateTime = moment.tz(dateString, 'MM/DD/YYYY h:mma', timezone);
                $hiddenWidget.val(dateTime.format(dateFormat));
            };

            $($dateWidget).datepicker().on('changeDate', updateDate);
            $($timeWidget).timepicker().on('changeTime', updateDate);

            $dateWidget.focus();
        }
    });

    var SCPinterestDateTimeEditCell = Backgrid.Extension.SCPinterestDateTimeEditCell = SCObjectBrowserEditCell.extend({
        form: SCPinterestDateEditCellFormTemplate,
        formatter: SCPinterestDateFormatter,
        dateFormat: 'YYYY-MM-DD',

        daysDifference: function(date) {
            var timeDiff = Math.abs(moment() - moment(date));
            return Math.ceil(timeDiff / (1000 * 3600 * 24));
        },

        prepareForm: function() {
            var columnName    = this.column.get('name');
            this.$('.sc-datetime-form').addClass(columnName);
            var currentValue  = moment(this.model.get(columnName));
            var minDays       = this.daysDifference(this.start_date) - 1;
            var maxDays       = this.daysDifference(this.end_date);
            var $hiddenWidget = this.$('#date_value');
            var $dateWidget   = this.$('input.datepicker');
            var dateFormat    = this.dateFormat;
            var updateDate;

            if (currentValue.isValid()) {
                $hiddenWidget.val(currentValue.toJSON());
                $dateWidget.val(currentValue.format('MM/DD/YYYY'));
            }

            $($dateWidget).datepicker({
                autoclose: true,
                endDate:   '+' + maxDays + 'd',
                startDate: '-' + minDays + 'd'
            });

            updateDate = function(e) {
                var date = moment($dateWidget.val(), 'MM/DD/YYYY');
                $hiddenWidget.val(date.format(dateFormat));
            };

            $($dateWidget).datepicker().on('changeDate', updateDate);

            $dateWidget.focus();
        }
    });

    var SCObjectBrowserDateTimeEditCell = Backgrid.Extension.SCObjectBrowserDateTimeEditCell = SCDateTimeEditCell.extend({
        /** Subclassed SCDateTimeEditCell to handle data payload preparation for the proxied endpoints used in object browser */
        saveChanges: function(changedData) {
            changedData.id = this.model.get('id');
            var objectData   = {
                updates: [changedData]
            };

            this.startSpinner();

            this.model.save(objectData, {
                url: this.updateUri(),
                silent: true,
                patch: true,
                success: _(success).bind(this),
                error: _(error).bind(this)
            });

            this.closePopover(null);
        }
    });

    var SCDateCell = Backgrid.Extension.SCDateCell = SCDateTimeEditCell.extend({
        /**
         * Checks if date is in the future.
         * @returns {Boolean} true if the date is in the future, otherwise returns false.
         */
        isValueEditable: function() {
            var modelKey   = this.column.get('name');
            var dateString = this.model.get(modelKey);
            var date       = moment(dateString);
            var now        = moment();

            return date.isAfter(now);
        }
    });

    var CurrencyCell = Backgrid.Extension.CurrencyCell = Backgrid.NumberCell.extend({
        className: 'currency-cell number-cell',
        formatter: Backgrid.Extension.CurrencyFormatter,
        divider: Backgrid.Extension.CurrencyFormatter.prototype.defaults.divider,
        /**
         * Initializes this cell and the number formatter.
         * @param {Object} options
         */
        initialize: function(options) {
            CurrencyCell.__super__.initialize.apply(this, arguments);
            var formatter = this.formatter;
            formatter.divider = this.divider;
        },
        render: function() {
            var value = this.model.get(this.column.get('name'));

            this.$el.empty();
            this.$el.text(this.formatter.fromRaw(value));
            this.delegateEvents();

            return this;
        }
    });

    var MicrodollarCell = Backgrid.Extension.MicrodollarCell = Backgrid.NumberCell.extend({
        className: 'microdollar-cell',
        renderNullAsZero: false,
        decimals: 2,
        decimalSeparator: '.',
        orderSeparator: ',',
        valueOverride: null,
        formatter: Backgrid.Extension.MicrodollarFormatter,

        render: function() {
            var value = this.valueOverride ? this.valueOverride() : this.model.get(this.column.get('name'));
            this.$el.empty();
            if (!_.isNull(value) || this.renderNullAsZero) {
                this.$el.text(this.formatter.fromRaw(value));
            }
            this.delegateEvents();
            return this;
        }
    });

    var SCBudgetCell = Backgrid.Extension.SCBudgetCell = Backgrid.Extension.SCObjectBrowserEditCell.extend({
        formatter: Backgrid.Extension.SCBudgetFormatter,

        form: SCBudgetCellTemplate,

        prepareForm: function() {
            var attribute  = this.column.get('name');
            var value      = this.model.get(attribute) / 100.0;
            var formattedValue;

            if (value === 0) {
                attribute = 'daily_budget';
                value = this.model.get(attribute) / 100.0;
            } else {
                this.$('input').data('attribute', attribute);
            }

            formattedValue = accounting.formatMoney(value, {
                format: '%v'
            });

            this.$('input').data('attribute', attribute).val(formattedValue);
        }
    });

    var SCMicrodollarBudgetCell = Backgrid.Extension.SCMicrodollarBudgetCell = Backgrid.Extension.SCObjectBrowserEditCell.extend({
        formatter: Backgrid.Extension.MicrodollarFormatter,

        form: SCBidEditCellTemplate,

        placement: 'bottom',

        prepareForm: function() {
            var attribute  = this.column.get('name');
            var value      = this.model.get(attribute) /  1000000.0;
            var formattedValue;

            this.$('input').data('attribute', attribute);

            formattedValue = accounting.formatMoney(value, {
                format: '%v'
            });

            this.$('input').data('attribute', attribute).val(formattedValue);
        }
    });

    var SCAccountName = Backgrid.Extension.SCAccountName = Backgrid.StringCell.extend({
        render: function() {
            var $name = CommonLanguage.en.getAccountNameHTML(this.model.toJSON());
            this.$el.html($name);
            return this;
        }
    });

    var SCUserInitiativeRole = Backgrid.Extension.SCUserInitiativeRole = Backgrid.StringCell.extend({
        render: function() {
            var $label = CommonLanguage.en.getUserInitiativeRoleHTML(this.model.toJSON());
            this.$el.html($label);
            return this;
        }
    });

    /**
     * Display avatar followed by either full name, or email (if no name)
     */
    var SCUserName = Backgrid.Extension.SCUserName = Backgrid.StringCell.extend({

        className: 'sc-user-name-cell',

        render: function() {
            var userNameHtml = CommonLanguage.en.getUserNameHTML(this.model.toJSON());
            this.$el.html(userNameHtml);
            return this;
        }
    });

    /**
     * Display either full name or email (if no name) only, no avatar
     */
    var SCUserNameOnly = Backgrid.Extension.SCUserNameOnly = Backgrid.StringCell.extend({
        render: function() {
            var userNameHtml = this.model.get('user') ?
                CommonLanguage.en.getUserNameHTML(this.model.get('user'))[0].innerText :
                '';
            this.$el.html(userNameHtml);
            return this;
        }
    });

    var SCPixelName = Backgrid.Extension.SCPixelName = Backgrid.StringCell.extend({
        render: function() {
            var $name = CommonLanguage.en.getPixelNameHTML(this.model.toJSON());
            this.$el.html($name);
            return this;
        }
    });

    var SCAdClusterActionCell = Backgrid.Extension.SCAdClusterActionCell = Backgrid.Cell.extend({
        className: 'sc-editable-status-cell sc-actions-cell',
        template: SCObjectBrowserButtonGroupCellTemplate,
        duplicateTemplate: CampaignDuplicateAdClusterModal,
        deleteTemplate: CampaignDeleteAdClusterModal,
        render: function() {
            var id = this.model.get('id');
            var name = this.model.get('name');
            var status = this.model.get('status');
            var actions = {
                canUpload: _.contains(['DRAFT'], status),
                canDuplicate: _.contains(['DRAFT', 'SUCCESS'], status),
                /* Hiding Download link until functionality is working */
                canDownload: true,
                // canDownload: true,
                canDelete: true,
                uploadHref: this.linkUri(),
                csvDownloadUri: '/api/advisor/v1/adcluster/' + this.model.get('id') + '/download_bulk_sheet',
                duplicateHref: 'duplicateAdClusterModal-' + id,
                deleteHref: 'deleteAdClusterModal-' + id
            };

            this.$el.html(this.template(actions))
                .append(
                    this.duplicateTemplate({id: id, name: name}),
                    this.deleteTemplate({id: id, name: name})
                );

            this.delegateEvents();
            return this;

        },
        events: {
            'click .sc-duplicate-adcluster-button': function(event) {
                var acID = this.model.get('id');
                // Get cloned Ad Cluster name
                var duplicateName = this.$('.modal-body #duplicate-name')[0].value;
                var successLink = this.duplicateSuccessLink();

                // Close modal
                $('#duplicateAdClusterModal-' + acID).modal('hide');

                // Send request to backend to copy Ad Cluster with new name
                $.ajax({
                    url: '/api/advisor/v1/adcluster/' + acID + '/clone/',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({
                        name: duplicateName
                    })
                }).done(function(data) {
                    // On success, transition to Ad Creation page for new, cloned Ad Cluster
                    AppChannel.trigger('navigate', successLink + data.id + '/', {trigger: true});
                }).fail(function(jqXHR, textStatus, error) {
                    console.log('Duplicate Ad Cluster failed with: ', error, jqXHR.responseText);
                });
            },
            'click .sc-delete-adcluster-button': function(event) {
                var acID = this.model.get('id');

                // Close modal
                $('#deleteAdClusterModal-' + acID).modal('hide');

                // Update model
                this.model.save({is_archived:true}, {
                    url: '/api/advisor/v1/adcluster/' + acID + '/',
                    silent: true,
                    patch: true,
                    success: _(success).bind(this),
                    error: _(error).bind(this)
                });
            }
        }

    });

    var SCButtonCell = Backgrid.Extension.SCButtonCell = Backgrid.Cell.extend({
        className: 'sc-button-cell',
        render: function() {
            var value = this.model.get(this.column.get('name')).toLowerCase();
            var $btn = $('<button />', {
                'class': 'btn sc-btn-' + value,
                'html': 'x'
            });
            this.$el.html($btn);
            this.delegateEvents();
            return this;
        }
    });
    var SCActionDropdownCell = Backgrid.Extension.SCActionDropdownCell = Backgrid.Cell.extend({
        template: SCActionDropdownCellTemplate,
        className: 'sc-button-cell',
        render: function() {
            var actions = this.formatter.fromRaw(this.model.id);
            this.$el.html(this.template(actions));
            this.delegateEvents();
            return this;
        }
    });

    var SCCopyToClipboardCell = Backgrid.Extension.SCCopyToClipboardCell = Backgrid.Cell.extend({
        template: SCClickToCopyCellTemplate,
        className: 'sc-copy-button-cell',
        render: function() {
            var value = this.model.get('code_snippet');
            var $btn = $('<input />', {
                'class': 'form-control input-sm sc-input-copyable',
                'value': value
            });
            this.$el.html(this.template({input_value: value}));
            this.delegateEvents();
            return this;
        }
    });
    var SCEmptyTableBody = Backgrid.Extension.SCEmptyTableBody = Backgrid.Body.extend({
        render: function(opts) {
            var tableBodyView = Backgrid.Body.prototype.render.apply(this, arguments);
            if (this.collection.length === 0) {
                tableBodyView.$el.html(this.emptyText);
            }
            return tableBodyView;
        }
    });

    var SCDurationCell = Backgrid.Extension.SCDurationCell = Backgrid.Cell.extend({
        className: 'sc-duration-cell',
        render: function() {
            var value = this.model.get(this.column.get('name'));
            if (!value) {
                return this;
            }
            var durationInfo = CommonLanguage.en.getDurationFromNowInfo(value);
            var html = durationInfo.durationString +
                (durationInfo.isPast ? ' ago ' : ' ') +
                '<small>' + durationInfo.date.format('MM/DD/YYYY') + '</small>';
            this.$el.html(html);
            return this;
        }
    });

    var SCUserAvatarCell = Backgrid.Extension.SCUserAvatarCell = Backgrid.Cell.extend({
        className: 'sc-user-avatar-cell',
        render: function() {
            var user = this.model.get('user');
            var userNameHtml;
            if (user) {
                userNameHtml = CommonLanguage.en.getUserNameHTML(user).children('img');
            }
            this.$el.html(userNameHtml);
            return this;
        }
    });

    /**
     * Display asset profile picture followed by its name.
     * Links to the asset in a new window.
     */
    var SCAssetName = Backgrid.Extension.SCAssetName = Backgrid.StringCell.extend({
        render: function() {
            var model = this.model.toJSON();
            var $link = $('<a/>', {
                'href': model.url,
                'html': CommonLanguage.en.getAssetNameHTML(model),
                'target': '_blank'
            });

            this.$el.html($link);
            this.delegateEvents();
            return this;
        }
    });

    var SCAdPreviewCell = Backgrid.Extension.SCAdPreviewCell = Backgrid.Cell.extend({
        className: 'sc-preview-cell',
        template: SCAdPreviewCellTemplate,
        render: function() {
            this.$el.html(this.template({id: this.model.get('id'), platform: this.platform}));
            this.$el.append(this.modalTemplate());
            this.delegateEvents();
            return this;
        },
        events: {
            'click .sc-creative-preview-link': function(event) {
                var objectId = $(event.currentTarget).data('object-id');
                var platform = $(event.currentTarget).data('platform');

                this.$('.modal-body').html(
                    this.previewTemplate(this.getPreviewTemplateParams(objectId, platform))
                );
                this.fillModalFromPlatform(this.$('.modal-body')[0]);
            }
        }
    });

    var SCFBAdPreviewCell = Backgrid.Extension.SCFBAdPreviewCell = SCAdPreviewCell.extend({
        modalTemplate: creativemodalTemplate,
        previewTemplate: facebookpreviewTemplate,
        getPreviewTemplateParams: function(objectId, platform) {
            var placement = platform === 'facebook' ? 'DESKTOP_FEED_STANDARD' : 'INSTAGRAM_STANDARD';
            return {
                adgroupId: objectId,
                placement: placement
            };
        },
        fillModalFromPlatform: function(modalBody) {
            FB.XFBML.parse(modalBody);
        }
    });

    var SCTWAdPreviewCell = Backgrid.Extension.SCTWAdPreviewCell = SCAdPreviewCell.extend({
        platform: 'twitter',
        modalTemplate: creativemodalTemplate,
        previewTemplate: twitterpreviewTemplate,
        getPreviewTemplateParams: function(objectId) {
            return {tweetId: objectId};
        },
        fillModalFromPlatform: function(modalBody) {
            var adPreview = $(modalBody).find('.tw-ad-preview');
            var tweetId = adPreview.data('tweet-id');
            $.ajax({
                url: '/api/twitter/ads/v1/twitterpromotedtweet/' + tweetId + '/preview/'
            }).done(function(data) {
                adPreview.html(data.data[0].preview);
            }).fail(function() {
                adPreview.html('Error retrieving preview');
            });
        }
    });

    // OLD

    /**
     * This Cell is specifically designed to be used in the Object Browser 'children' table of the
     * Campaign Details view.
     */
    var SCResultsCell = Backgrid.Extension.SCResultsCell = Backgrid.StringCell.extend({
        className: 'sc-results-cell number-cell',

        numberFormatter: new Backgrid.NumberFormatter({
            decimals: 0
        }),

        render: function() {
            var campaignModel = AppChannel.request('mainRegion').currentView.model;
            var platform = campaignModel.get('platform').toLowerCase();
            var platformObjective = platform === 'facebook' ? 'objective' : platform + '_objective';
            var objective = campaignModel.get('objective');
            var objective_label = CommonLanguage.en[platformObjective][objective].toLowerCase();
            var value = this.numberFormatter.fromRaw(Number(this.model.get('kpi_primary_events')));

            this.$el.empty()
                .append(value)
                .append($('<small>').css('display', 'block').text(objective_label));

            this.delegateEvents();

            return this;
        }
    });

    /**
     * This Cell is specifically designed to be used in the Object Browser 'children' table of the
     * Campaign Details view.
     */
    var SCPerformanceCell = Backgrid.Extension.SCPerformanceCell = Backgrid.StringCell.extend({
        className: 'sc-objective-cell number-cell',

        formatMoney: function(val) {
            return accounting.formatMoney(val);
        },

        render: function() {
            var campaignModel = AppChannel.request('mainRegion').currentView.model;
            var kpi_label = campaignModel.kpiLabel().toLowerCase();
            var value = this.formatMoney(this.model.get('kpi_primary'));

            this.$el.empty()
                .append(value)
                .append($('<small>').css('display', 'block').text(kpi_label));

            this.delegateEvents();

            return this;
        }
    });

    var SCMicrodollarPerformanceCell = Backgrid.Extension.SCMicrodollarPerformanceCell = SCPerformanceCell.extend({
        className: 'sc-objective-cell number-cell',
        decimals: 2,

        formatMoney: function(val) {
            return accounting.formatMoney((val / 1000000.0).toFixed(~~this.decimals));
        }
    });

    var SCObjectiveTextCell = Backgrid.Extension.SCObjectiveTextCell = Backgrid.StringCell.extend({
        className: 'string-cell-left',

        render: function() {
            var key = this.model.get('lineitem__payout_action');
            var objective = key ? CommonLanguage.en.objective_classic[key.toUpperCase()] : '';

            this.$el.html(objective);
            this.delegateEvents();

            return this;
        }
    });

    var SCBidCell = Backgrid.Extension.SCBidCell = Backgrid.Extension.SCObjectBrowserEditCell.extend({
        form: SCBidEditCellTemplate,

        placement: 'bottom',

        render: function() {
            var editLink = $('<div/>').addClass('sc-edit-link');

            // Intentionally emptying here because we could end up in an inbetween state if we do not.
            this.$el.empty().addClass('sc-inline-edit-cell');

            if (_.isFunction(this.form)) {
                this.form = this.form();
            }

            var label = _string.humanize(this.model.get('optimization_goal'));
            var cellHTML = accounting.formatMoney(this.model.get('bid_amount') / 100.0);

            cellHTML += ' <br /><small>' + label + '</small>';

            var icon = '';

            if (this.editingEnabled()) {
                icon = '<i class="fa fa-pencil sc-edit-icon"></i>';
            }

            this.$el.append($('<span>')
                .addClass('popover-trigger sc-edit-link')
                .html(cellHTML + icon)
            );

            if (this.editingEnabled()) {
                this.$('.sc-edit-link').addClass('enabled');

                var popover = $(this.$('i.fa')).popover({
                    html: true,
                    content: this.form,
                    placement: this.placement,
                    trigger: 'manual'
                });
            }

            this.delegateEvents();

            return this;
        },

        prepareForm: function() {
            var attribute      = 'bid_amount';
            var value          = this.model.get('bid_amount');
            var formattedValue = accounting.formatMoney(value / 100, {
                                     format: '%v'
                                 });

            this.$('input').data('attribute', attribute).val(formattedValue);
        },

        saveChanges: function(changedData) {
            changedData.bid_amount = changedData.bid_amount * 100;
            changedData.id = this.model.get('id');

            var objectData   = {
                updates: [changedData]
            };

            this.startSpinner();

            this.model.save(objectData, {
                url: this.updateUri(),
                silent: true,
                patch: true,
                success: _(success).bind(this),
                error: _(error).bind(this)
            });

            this.closePopover(null);
        }
    });

    var EndDateFormatter = Backgrid.Extension.EndDateFormatter = function(options) {
        _.extend(this, this.defaults, options || {});
    };

    EndDateFormatter.prototype = new Backgrid.StringFormatter();

    _.extend(EndDateFormatter.prototype, {
        // Takes attribute value and formats for display to user
        fromRaw: function(value, model) {
            var dateTime = moment(value).endOf('day');
            var daysLeft;
            var label;
            var hoursLeft;

            if (value && dateTime.isValid()) {
                // Since end date is supposed to be inclusive (e.g. an end date of 2015-12-31 means that
                // it goes until the END of the 31st) we handle this by looking at the endOf day
                daysLeft = dateTime.diff(moment(), 'days', true);
                if (daysLeft < 1) {
                    hoursLeft = moment.duration(daysLeft, 'd').asHours();
                    label = hoursLeft < 0 ? 'Completed' : parseInt(hoursLeft, 10) + ' hours';
                } else if (daysLeft < 2) {
                    label = parseInt(daysLeft, 10) + ' day';
                } else {
                    label = parseInt(daysLeft, 10) + ' days';
                }

                return label + dateTime.format(' <br /> <\\s\\m\\a\\l\\l>MM/DD/YYYY</\\s\\m\\a\\l\\l>');
            }

            return '<small>N/A</small>';
        }
    });

    var SCNumberHeaderCell = Backgrid.Extension.SCNumberHeaderCell = Backgrid.HeaderCell.extend({
        onClick: function(e) {
            e.preventDefault();

            var column     = this.column;
            var collection = this.collection;
            var event      = 'backgrid:sort';
            var sortable;
            var sortType;
            var cycleSort;
            var toggleSort;

            cycleSort = function(header, col) {
                if (column.get('direction') === 'ascending') {
                    collection.trigger(event, col, 'descending');
                } else if (column.get('direction') === 'descending') {
                    collection.trigger(event, col, null);
                } else {
                    collection.trigger(event, col, 'descending');
                }
            };

            toggleSort = function(header, col) {
                if (column.get('direction') === 'descending') {
                    collection.trigger(event, col, 'ascending');
                } else {
                    collection.trigger(event, col, 'descending');
                }
            };

            sortable = Backgrid.callByNeed(column.sortable(), column, this.collection);

            if (sortable) {
                sortType = column.get('sortType');

                if (sortType === 'toggle') {
                    toggleSort(this, column);
                } else {
                    cycleSort(this, column);
                }
            }
        }
    });

    var SCCurrencyCell = Backgrid.Extension.SCCurrencyCell = Backgrid.NumberCell.extend({
        formatter: SCCurrencyFormatter
    });

    var CurrencyInCentsFormatter = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue, model) {
            if (!Helpers.valueIsValid(rawValue)) {
                return '-';
            }

            rawValue = rawValue / 100;
            return accounting.formatMoney(accounting.toFixed(rawValue, 2), {
                precision: 0
            });
        }
    });

    var SCCurrencyInCentsCell = Backgrid.Extension.SCCurrencyInCentsCell = Backgrid.NumberCell.extend({
        formatter: CurrencyInCentsFormatter
    });

    var ActionNumberFormatter = function() {
        Backgrid.NumberFormatter.apply(this, arguments);
    };

    ActionNumberFormatter.prototype = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue) {
            if (!Helpers.valueIsValid(rawValue)) {
                return '-';
            }

            this.decimals = 0;
            rawValue = parseInt(Math.round(rawValue));

            return Backgrid.NumberFormatter.prototype.fromRaw.call(this, rawValue);
        }
    });

    var SCActionNumberCell = Backgrid.Extension.SCActionNumberCell = Backgrid.NumberCell.extend({
        formatter: ActionNumberFormatter
    });

    var SCReachFormatter = function() {
        Backgrid.NumberFormatter.apply(this, arguments);
    };

    SCReachFormatter.prototype = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue) {
            if (!Helpers.valueIsValid(rawValue)) {
                return '-';
            }

            this.decimals = 0;
            rawValue = parseInt(Math.round(rawValue));

            return Backgrid.NumberFormatter.prototype.fromRaw.call(this, rawValue);
        }
    });

    var SCReachCell = Backgrid.Extension.SCReachCell = Backgrid.NumberCell.extend({
        formatter: SCReachFormatter
    });

    var SCFrequencyFormatter = function() {
        Backgrid.NumberFormatter.apply(this, arguments);
    };

    SCFrequencyFormatter.prototype = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue) {
            var model_attributes = arguments[1].attributes;
            var reach = model_attributes.reach;

            if (!Helpers.valueIsValid(rawValue)) {
                return 'Unavailable';
            }

            if (model_attributes.impressions === 0) {
                return 0;
            }

            return Backgrid.NumberFormatter.prototype.fromRaw.call(this, rawValue);
        }
    });

    var SCFrequencyCell = Backgrid.Extension.SCFrequencyCell = Backgrid.NumberCell.extend({
        formatter: SCFrequencyFormatter
    });

    var DecimalFormatter = function() {
        Backgrid.NumberFormatter.apply(this, arguments);
    };

    DecimalFormatter.prototype = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue) {
            if (!Helpers.valueIsValid(rawValue)) {
                return '-';
            }

            return Backgrid.NumberFormatter.prototype.fromRaw.call(this, rawValue);
        }
    });

    var SCDecimalCell = Backgrid.Extension.SCDecimalCell = Backgrid.NumberCell.extend({
        formatter: DecimalFormatter
    });

    var ThreeDecimalPercentFormatter = function() {
        Backgrid.NumberFormatter.apply(this, arguments);
    };

    ThreeDecimalPercentFormatter.prototype = _.extend({}, Backgrid.NumberFormatter.prototype, {
        fromRaw: function(rawValue) {
            if (!Helpers.valueIsValid(rawValue)) {
                return '-';
            }

            this.decimals = 3;

            return Backgrid.NumberFormatter.prototype.fromRaw.call(this, rawValue) + '%';
        }
    });

    var SCThreeDecimalPercentCell = Backgrid.Extension.SCThreeDecimalPercentCell = Backgrid.NumberCell.extend({
        formatter: ThreeDecimalPercentFormatter
    });

    var SCKPIResultsCell = Backgrid.Extension.SCKPIResultsCell = Backgrid.IntegerCell.extend({
        formatter: Backgrid.NumberFormatter,

        // TODO: DRY up with other render methods.
        render: function() {
            var cellHTML = this.formatter.fromRaw(this.model.get('kpi_primary_events'));
            var label = CommonLanguage.en.results[this.model.get('objective')];

            if (label) {
                cellHTML += '<br /><small class="text-muted">' + label + '</small>';
            }

            this.$el.html(cellHTML);
            this.delegateEvents();

            return this;
        }
    });

    var SCKPICell = Backgrid.Extension.SCKPICell = Backgrid.IntegerCell.extend({
        formatter: CurrencyFormatter,

        // TODO: DRY up with other render methods.
        render: function() {
            var cellHTML = accounting.formatMoney(this.model.get('kpi'));
            var label = CommonLanguage.en.kpi[this.model.get('objective')];

            if (label) {
                cellHTML += '<br /><small class="text-muted">' + label + '</small>';
            }

            this.$el.html(cellHTML);
            this.delegateEvents();

            return this;
        }
    });

    var SCAnalyticsDateCell = Backgrid.Extension.SCAnalyticsDateCell = Backgrid.DateCell.extend({
        className: 'string-cell-left',

        formatter: Backgrid.DatetimeFormatter,

        render: function() {
            var date = this.formatter.fromRaw(this.model.get('date_start'));

            this.$el.html(moment(date).format('MM/DD/YY'));
            this.delegateEvents();

            return this;
        }
    });

    var SCSelectRowCell = Backgrid.Extension.SCSelectRowCell = SelectRowCell.extend({
        initialize: function(options) {
            this.listenTo(this.model, 'advisor:audience-removed', function(model) {
                this.$el.html('<i class="fa fa-plus-square fa-2x text-danger"></i>');
                this.delegateEvents();
                return this;
            });
            this.listenTo(this.model, 'advisor:model-selected', function(model) {
                this.$el.html('<i class="fa fa-check-circle-o fa-2x text-success"></i>');
                this.delegateEvents();
                return this;
            });
        },
        className: 'sc-select-plus-cell',
        events: {
            'click .fa-plus-square': 'selectRow'
        },
        selectRow: function() {
            this.model.trigger('advisor:audience-selected', this.model, true);
            this.$el.html('<i class="fa fa-check-circle-o fa-2x text-success"></i>');
            this.delegateEvents();
            return this;
        },
        render: function() {
            this.$el.html('<i class="fa fa-plus-square fa-2x text-danger"></i>');
            this.delegateEvents();
            return this;
        }
    });

    var SCSelectAllActionHeaderCell = Backgrid.Extension.SCSelectAllActionHeaderCell = Backgrid.Extension.SelectAllHeaderCell.extend({

        /** Handlebars template */
        template: SCSelectAllActionHeaderCellTemplate,

        /** Initializer */
        initialize: function(options) {

            /** Listen to collection */
            this.listenTo(this.collection, 'backgrid:selected', this.selected);
            this.listenTo(this.collection, 'sc:select-all-action-header:success', this.resetPicked);

        },

        /** Render */
        render: function() {

            /** Create template */
            var template = this.template({
                selection: this.selection || []
            });

            /** Add template to dom */
            this.$el.html(template);

            /** Delegate event and return this */
            return this.delegateEvents() && this;

        },

        /** Add models to selected collection */
        selected: function(model, add) {

            /**
             * This is not an ideal solution. We should be using getSelectedModels().
             *
             * There is either a bug in the code or we implemented backgrid
             * incorrectly, therefor we don't have access to the function.
             *
             * This is a temporary fix until we clean up backgrid.
             */

            /** Create collection if selectedModels are missing */
            this.picked = this.picked || new Backbone.Collection();

            /** Add or remove models */
            this.picked[add ? 'add' : 'remove'].call(this.picked, model);

            /** Trigger callback */
            this.onSelected && this.onSelected.call(this, this.picked);

            /** Disable dropdown if there are no selections */
            $('[data-toggle=dropdown]', this.el).prop('disabled', !this.picked.length);

        },

        /** Reset this.picked after a successful bulk update */
        resetPicked: function() {
            this.picked.reset(null);
        }

    });

    var SCAudienceSizeCell = Backgrid.Extension.SCAudienceSizeCell = Backgrid.IntegerCell.extend({
        render: function() {
            var cellHTML = numeral(this.model.get('size')).format('0.[000]a');
            var updated = moment(this.model.get('updated_date')).format('MM/DD/YY');

            if (updated) {
                cellHTML += ' <br /> <small class="text-muted">' + updated + '</small>';
            }
            this.$el.html(cellHTML);
            this.delegateEvents();
            return this;
        }
    });

    Backgrid.Extension.WrappedTextCell = Backgrid.Cell.extend({
        render: function() {
            var value = this.model.get(this.column.get('name'));
            this.$el.css('white-space', 'normal').html(this.formatter.fromRaw(value));
            this.delegateEvents();
            return this;
        }
    });

    var SCTotalSpendCell = Backgrid.Extension.SCTotalSpendCell = Backgrid.Extension.CurrencyCell.extend({
        template: SCTotalSpendCellTemplate,
        className: 'sc-pacing-cell currency-cell',

        render: function() {
            this.$el.html(this.template(Helpers.getPacingOptions(this.model)));

            this.delegateEvents();
            return this;
        }
    });

    var SCMicroObjectiveCell = Backgrid.Extension.SCMicroObjectiveCell = Backgrid.Extension.MicrodollarCell.extend({
        className: 'sc-objective-cell number-cell',
        render: function() {
            var label = this.model.get('funding_instrument_id') ? 'Per Engagement' : 'Per Event';
            var cellHTML = this.formatter.fromRaw(this.model.get('kpi_primary'));

            cellHTML += ' <br /> <small>' + label + '</small>';
            this.$el.html(cellHTML);
            this.delegateEvents();
            return this;
        }
    });

})();
