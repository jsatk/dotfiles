/* global dependencies */
var _ = require('underscore');
var $ = require('jquery');
var moment = require('moment');
var Backbone = require('backbone');
var AppChannel = require('advisor/app-channel');

/* local dependencies */
var Base = require('../base.js');
var TastypiePageableCollection = require('../../config/TastypiePageableCollection');

var Initiative = Backbone.Model.extend({
    urlRoot: '/api/advisor/v1/initiative/',
    validate: function(attrs) {
        // TODO: Change this to use moment's #isBefore or #isAfter methods.
        if (new Date(attrs.end_date) < new Date(attrs.start_date)) {
            return { end_date: 'End Date cannot be before Start Date' };
        }
    },
    setBrand: function() {
        this.set('hasBrand', $.Deferred());
        var brandID     = this.get('brand_id');
        var onDoneFetch = function(brand) {
            this.set('brand', brand);
            this.get('hasBrand').resolve(brand);
        };
        AppChannel.request('brand:entity', brandID).done(_.bind(onDoneFetch, this));
        return this;
    },
    setFollowers: function() {
        var followersPageableEntities = new FollowerPageableCollection([], {
            urlPrefix: this.urlRoot + this.id
        });
        this.set('followers', followersPageableEntities);
        return this;
    },
    initialize: function() {
        this.setFollowers();
        this.on('change:brand_id', this.setBrand, this);
        if (this.collection) {
            // Load brands on page load/switch
            this.collection.on('sync', this.setBrand, this);
        }
    },
    doPatch: function(attributes, defer) {
        this.save(attributes, {
            contentType: 'application/json',
            patch: true,
            wait: true,
            success: function(model) {
                defer.resolve(model);
            },
            error: function(model, response) {
                defer.reject(model, response);
            }
        });
    },
    /**
     * Workaround for backend PATCH race conditions
     * @param  {Object} attributes - model attributes to patch
     * @return {$.Promise}
     */
    patch: function(attributes) {
        var defer = $.Deferred();
        var lastDefer = this._lastPatchDefer;
        if (lastDefer) {
            lastDefer.then(function(model) {
                model.doPatch(attributes, defer);
            });
        } else {
            this.doPatch(attributes, defer);
        }
        this._lastPatchDefer = defer;
        return defer.promise();
    },
    userCanManage: function() {
        return AppChannel.request(
            'session:grant:entities:can_manage_brand_or_initiative', this.get('brand_id'), this.get('id')
        );
    }
});
var InitiativeCollection = TastypiePageableCollection.extend({
    /**
     * @param {Backbone.Model} initiative
     * This collection sorts by the `status` first, then the `end_date`.
     */
    comparator: function(initiative) {
        // Sorts by `end_date` with the oldest/soonest dates coming first.
        var date  = -moment(initiative.get('end_date')).format('YYYYMMDDHHmmss');
        var index = _([
                'ACTIVE',
                'PAUSED',
                'INACTIVE',
                'COMPLETED'
            ]).indexOf(initiative.get('status'));

        return [ index, date ];
    },
    model: Initiative,
    url: Initiative.prototype.urlRoot
});
var InitiativePageableCollection = TastypiePageableCollection.extend({
    model: Initiative,
    url: Initiative.prototype.urlRoot
});
var FollowerPageableCollection = TastypiePageableCollection.extend({
    url: function() {
        return this.urlPrefix + '/follower/';
    },
    initialize: function(models, options) {
        this.urlPrefix = options.urlPrefix;
    }
});
var fetchInitiative = _(function(id) {
    var defer = $.Deferred();
    this.fetchEntity(Initiative, id, true).done(function(initiative) {
        $.when(initiative.get('hasBrand')).done(function(brand) {
            defer.resolve(initiative);
        });
    });
    return defer.promise();
}).bind(Base);
var fetchInitiativeCollection = _(function(options) {
    return this.fetchEntities(InitiativeCollection, options);
}).bind(Base);

var handlers = [
    ['advisor:initiative:entity',           function(id) {      return fetchInitiative(id);                }],
    ['advisor:initiative:entities',         function(options) { return fetchInitiativeCollection(options); }],
    ['advisor:initiative:Entity',           function() {        return Initiative;                         }],
    ['advisor:initiative:Entities',         function() {        return InitiativeCollection;               }],
    ['advisor:initiative:PageableEntities', function() {        return InitiativePageableCollection;       }]
];

_(handlers).each(function(handler) {
    AppChannel.reply(handler[0], handler[1]);
});
