import Validatable from 'advisor/extensions/Validatable'
import $ from 'jquery'
import Marionette from 'backbone.marionette'

const TestRegion = Marionette.Region.extend({})

describe('Validatable extension', () => {

    var region

    beforeEach(() => {
        region = new TestRegion({
            el: $('<div>')
        })
    })

    afterEach(() => region.reset())

    describe('options', () => {

        it('should throw if root element is not a form', () => {
            var View = Marionette.View.extend(new Validatable({
                el: $('<div>')
            }))
            var myView = new View()
            expect(() => {
                region.show(myView)
            }).toThrowError()
        })

        it('should default inline to true', () => {
            var View = Marionette.View.extend(new Validatable({
                inline: undefined, // explicitly set to undefined to demonstrate default behavior
                el: $('<form>')
            }))
            var v = new View()
            expect(v.inline).toBe(true)
        })
    })

    describe('when extended', () => {
        it('should add a _submitted handler', () => {
            var View = Marionette.View.extend(new Validatable({
                el: $('<form>')
            }))
            var v = new View()
            expect(v._submitted).toBeDefined()
            expect(typeof v._submitted).toEqual('function')
        })
        it('should add an _errors array', () => {
            var View = Marionette.View.extend(new Validatable({
                el: $('<form>')
            }))
            var v = new View()
            expect(v._errors).toBeDefined()
            expect(Array.isArray(v._errors)).toBe(true)
        })
        it('should have a validate hash', () => {
            var View = Marionette.View.extend(new Validatable({
                el: $('<form>')
            }))
            var v = new View()
            expect(v.validate).toBeDefined()
            expect(typeof v.validate).toBe('object')
        })
        it('should add a `displayErrors` function', () => {
            var View = Marionette.View.extend(new Validatable({
                el: $('<form>')
            }))
            var v = new View()
            expect(v.displayErrors).toBeDefined()
            expect(typeof v.displayErrors).toEqual('function')
        })
        it('should add a `clearErrors` function', () => {
            var View = Marionette.View.extend(new Validatable({
                el: $('<form>')
            }))
            var v = new View()
            expect(v.clearErrors).toBeDefined()
            expect(typeof v.clearErrors).toEqual('function')
        })
        it('should add an `addError` function', () => {
            var View = Marionette.View.extend(new Validatable({
                el: $('<form>')
            }))
            var v = new View()
            expect(v.addError).toBeDefined()
            expect(typeof v.addError).toEqual('function')
        })
    })

    describe('when submitting', () => {

        let view

        beforeEach(() => {
            var View = Marionette.View.extend(new Validatable({
                inline: false,
                el: $('<form>')
            }))
            view = new View()
        })

        it('should call _submitted when submitting', () => {
            /**
             * this is a weird edge case - if you submit a form in a test, it'll reload the page (since default method is GET and default location is the current one).
             * Because this is running inside of a runner, jasmine will actually reload the page.
             * Which means that without this stub (or somewhere else calling e.preventDefault()), this would cause the tests to get to this point, then start over, forever.
             * ~jd
             */
            view.$el.on('submit', e => e.preventDefault())
            spyOn(view, '_submitted')
            region.show(view)
            view.$el.submit()
            expect(view._submitted).toHaveBeenCalled()
        })

        it('should automatically validate required fields', () => {
            view.$el.append('<input type="text" required name="text"/>')
            region.show(view)
            // don't recurse (calling a new URL will cause test recursion)
            view.$el.on('submit', e => e.preventDefault())
            view.$el.submit()
            expect(view._errors.length).toEqual(1)
            expect(view._errors[0].error).toEqual('invalid text')
        })

        it('should preventDefault if there is an error', () => {
            view.$el.append('<input type="text" required name="text"/>')
            region.show(view)
            view.$el.on('submit', e => {
                expect(e.isDefaultPrevented()).toBe(true)
                // in case the above fails, don't recurse (calling a new URL will cause test recursion)
                e.preventDefault()
            })
            view.$el.submit()
            expect(view._errors.length).toEqual(1)
        })

        it('should not preventDefault if there are no errors', () => {
            view.$el.append('<input type="text" value="foo" required name="text"/>')
            region.show(view)
            view.$el.on('submit', e => {
                expect(view._errors.length).toEqual(0)
                expect(e.isDefaultPrevented()).toBe(false)
                // don't recurse (calling a new URL will cause test recursion)
                e.preventDefault()
            })
            view.$el.submit()
        })
    })

    describe('when passed a validate array', () => {

        let view, fooEl, barEl, bazEl

        beforeEach(() => {
            var View = Marionette.View.extend(new Validatable({
                inline: false,
                el: $('<form>'),
                validate: {
                    foo: function() { return null },
                    bar: function() { return null }
                }
            }))
            view = new View()

            fooEl = $('<input type="text" name="foo"/>')
            barEl = $('<input type="text" name="bar"/>')
            bazEl = $('<input type="text" name="baz"/>')
            view.$el.append(fooEl)
            view.$el.append(barEl)
            view.$el.append(bazEl)

            // don't recurse (calling a new URL will cause test recursion)
            view.$el.on('submit', e => e.preventDefault())
            view.$el.on('submit', e => {
                e.preventDefault()
            })
            region.show(view)
        })

        it('should perform the validations in the validate hash', () => {
            spyOn(view.validate, 'foo')
            spyOn(view.validate, 'bar')
            view.$el.submit()
            expect(view.validate.foo).toHaveBeenCalled()
            expect(view.validate.bar).toHaveBeenCalled()
        })

        it('should add an error if a validation fails', () => {
            view.validate.foo = function(el, name) {
                return '凸(>皿<)凸'
            }
            view.displayErrors = function(errors) {
                expect(errors.length).toEqual(1)
                expect(errors[0].error).toEqual('凸(>皿<)凸')
            }
            view.$el.submit()
        })

        it('should add an error when calling addError', () => {
            view.$el.submit()
            view.addError(bazEl, '(ʘ言ʘ╬)')
            expect(view._errors.length).toEqual(1)
            expect(view._errors[0].error).toEqual('(ʘ言ʘ╬)')
        })
    })

    describe('displaying errors', () => {
        describe('default error display', () => {
            let view, errEl

            beforeEach(() => {
                var View = Marionette.View.extend(new Validatable({
                    inline: false,
                    el: $('<form><div class="form-group"><input type="text" id="foo" name="foo"/></div><input type="text" id="bar"/></form>'),
                    validate: {
                        foo: function() { return 'ERROR' }
                    }
                }))
                view = new View()

                view.$el.on('submit', e => {
                    // don't recurse (calling a new URL will cause test recursion)
                    e.preventDefault()
                })
                region.show(view)
                errEl = view.$el.find('#foo')
                view.$el.submit()
            })

            it('should set a class on a containing form-group', () => {
                expect(errEl.closest('.form-group').hasClass('has-error')).toBe(true)
            })

            it('should set a class on the input element', () => {
                expect(errEl.hasClass('error')).toBe(true)
            })

            it('should add a bootstrap tooltip with the error message', () => {
                var tt = errEl.data('bs.tooltip')
                expect(tt).toBeDefined()
                expect(tt.options.title).toEqual('ERROR')
            })

            describe('when adding a new error', () => {
                var newErrorEl
                beforeEach(() => {
                    var msg = '(つ･･)つ¤=[]:::::::>'
                    newErrorEl = view.$el.find('#bar')
                    view.addError(newErrorEl, msg)
                })
                it('should add error classes to the new error element', () => {
                    expect(newErrorEl.hasClass('error')).toBe(true)
                })
                it('should not clear other errors', () => {
                    expect(errEl.hasClass('error')).toBe(true)
                })
            })

            it('should clear errors when clearErrors is called', () => {
                view.clearErrors()
                expect(errEl.hasClass('error')).toBe(false)
                expect(errEl.closest('.form-group').hasClass('has-error')).toBe(false)
                var tt = errEl.data('bs.tooltip')
                expect(tt).not.toBeDefined()
                expect(view._errors.length).toEqual(0)
            })
        })
    })

    describe('validators', () => {
        describe('Validatable.TEXT', () => {
            let validator
            describe('no arguments', () => {
                beforeEach(() => {
                    validator = Validatable.TEXT()
                })
                it('should return a function', () => {
                    expect(typeof validator).toEqual('function')
                })
                it('should fail when input has no value', () => {
                    expect(validator($('<input value="">'))).not.toBeNull()
                })
                it('should succeed when input value is longer than 2 characters', () => {
                    expect(validator($('<input value="hello">'))).toBeNull()
                })
            })
            describe('a min argument', () => {
                beforeEach(() => {
                    validator = Validatable.TEXT(7)
                })
                it('should fail when input value is < 7 characters', () => {
                    expect(validator($('<input value="hello">'))).not.toBeNull()
                })
                it('should succeed when input value is 7 characters', () => {
                    expect(validator($('<input value="jacuzzi">'))).toBeNull()
                })
            })
            describe('min and max arguments', () => {
                beforeEach(() => {
                    validator = Validatable.TEXT(7, 12)
                })
                it('should fail when input value is > 12 characters', () => {
                    expect(validator($('<input value="ABBREVIATIONS">'))).not.toBeNull()
                })
                it('should succeed when input value is 9 characters', () => {
                    expect(validator($('<input value="BOLTHOLES">'))).toBeNull()
                })
            })
        })
        describe('Validatable.VALUE', () => {
            it('should return a function', () => {
                expect(typeof Validatable.VALUE()).toEqual('function')
            })
            it('should fail when a select has nothing selected', () => {
                var sel = $('<select><option value="">default</option><option value="foo">foo</option></select>')
                expect(Validatable.VALUE()(sel)).not.toBeNull()
            })
            it('should fail when a select has a selection', () => {
                var sel = $('<select><option value="">default</option><option selected value="foo">foo</option></select>')
                expect(Validatable.VALUE()(sel)).toBeNull()
            })
            it('should call a function when failing if passed one', () => {
                var called = false
                var v = Validatable.VALUE(function() {
                    called = true
                    return 'My Error'
                })
                var sel = $('<select><option value="">default</option><option value="foo">foo</option></select>')
                var err = v(sel)
                expect(err).not.toBeNull()
                expect(called).toBe(true)
                expect(err).toEqual('My Error')
            })
        })
        describe('Validatable.REGEX', () => {
            it('should throw when not called with args', () => {
                expect(() => Validatable.REGEX()).toThrow()
            })
            it('should throw when not passed a regex', () => {
                expect(() => Validatable.REGEX('HUEHUEHUE')).toThrow()
            })
            it('should return a function when passed a regex', () => {
                var v = Validatable.REGEX(/^coffin/)
                expect(typeof v).toEqual('function')
            })
            it('should fail when the regex does not match the input value', () => {
                var v = Validatable.REGEX(/^coffin/)
                expect(v($('<input value="">'))).not.toBeNull()
            })
            it('should fail when the regex matches the input value', () => {
                var v = Validatable.REGEX(/^coffin/)
                expect(v($('<input value="coffin">'))).toBeNull()
            })
            describe('when passed a message function', () => {
                it('should return the specified message when failing', () => {
                    var msg = 'NOT COFFIN, IDIOT';
                    var v = Validatable.REGEX(/^coffin/, () => { return msg })
                    expect(v($('<input value="">'))).toEqual(msg)
                })
            })
        })
        describe('Validatable.NUMBER', () => {
            let validator
            describe('no arguments', () => {
                beforeEach(() => {
                    validator = Validatable.NUMBER()
                })
                it('should return a function', () => {
                    expect(typeof validator).toEqual('function')
                })
                it('should fail when input has no value', () => {
                    expect(validator($('<input value="">'))).not.toBeNull()
                })
                it('should fail when input value is not a number', () => {
                    expect(validator($('<input value="foo">'))).not.toBeNull()
                })
                it('should succeed when input value is a number', () => {
                    expect(validator($('<input value="10">'))).toBeNull()
                })
            })
            describe('a min argument', () => {
                beforeEach(() => {
                    validator = Validatable.NUMBER(0)
                })
                it('should fail when input value is < 0', () => {
                    expect(validator($('<input value="-1">'))).not.toBeNull()
                })
                it('should succeed when input value is 0', () => {
                    expect(validator($('<input value="0">'))).toBeNull()
                })
            })
            describe('min and max arguments', () => {
                beforeEach(() => {
                    validator = Validatable.NUMBER(7, 12)
                })
                it('should fail when input value is > 12', () => {
                    expect(validator($('<input value="13">'))).not.toBeNull()
                })
                it('should succeed when input value is 9', () => {
                    expect(validator($('<input value="9">'))).toBeNull()
                })
            })
        })
    })
})
